From 52fa57314df2d8c2ad1d3fa88fecee8c155db93c Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Wed, 14 May 2025 17:03:38 +0000
Subject: [PATCH 01/25] *: Add locator to SID release API

Daemons can release an SRv6 SID by calling the
srv6_manager_release_sid() API exposed by SID Manager.

Currently, the srv6_manager_release_sid() API takes two arguments:
zclient and SID context to be released. So far, these two arguments
were enough to release a SID, because a SID was uniquely identified by
the SID context.

int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx);

However, with the support from multiple locators, a SID context can be
allocated from multiple locators. This means that the SID context is no
longer sufficient to uniquely identify a SID. Instead, a SID is
uniquely identified by the pair (SID context, locator).

This commit extends the srv6_manager_release_sid() API by adding a new
argument locator_name.

int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
				    const char *locator_name);

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 bgpd/bgp_mplsvpn.c     | 20 +++++++++---------
 bgpd/bgp_zebra.c       |  7 ++++---
 bgpd/bgp_zebra.h       |  2 +-
 isisd/isis_srv6.c      |  4 ++--
 isisd/isis_zebra.c     |  7 ++++---
 isisd/isis_zebra.h     |  2 +-
 lib/zclient.c          | 19 +++++++++++++++--
 lib/zclient.h          |  4 ++--
 staticd/static_zebra.c |  2 +-
 zebra/zapi_msg.c       | 17 +++++++++++++++-
 zebra/zebra_srv6.c     | 46 +++++++++++++++++++++++++++++-------------
 zebra/zebra_srv6.h     | 11 +++++-----
 12 files changed, 96 insertions(+), 45 deletions(-)

diff --git a/bgpd/bgp_mplsvpn.c b/bgpd/bgp_mplsvpn.c
index b00f3d189c72..c2736cd1fafe 100644
--- a/bgpd/bgp_mplsvpn.c
+++ b/bgpd/bgp_mplsvpn.c
@@ -534,7 +534,7 @@ void vpn_leak_zebra_vrf_sid_withdraw_per_af(struct bgp *bgp, afi_t afi)
 	ctx.vrf_id = bgp->vrf_id;
 	ctx.behavior = afi == AFI_IP ? ZEBRA_SEG6_LOCAL_ACTION_END_DT4
 				     : ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
-	bgp_zebra_release_srv6_sid(&ctx);
+	bgp_zebra_release_srv6_sid(&ctx, bgp->vpn_policy[afi].tovpn_sid_locator->name);
 }
 
 /*
@@ -576,7 +576,7 @@ void vpn_leak_zebra_vrf_sid_withdraw_per_vrf(struct bgp *bgp)
 
 	ctx.vrf_id = bgp->vrf_id;
 	ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
-	bgp_zebra_release_srv6_sid(&ctx);
+	bgp_zebra_release_srv6_sid(&ctx, bgp->tovpn_sid_locator->name);
 }
 
 /*
@@ -963,19 +963,19 @@ void delete_vrf_tovpn_sid_per_af(struct bgp *bgp_vpn, struct bgp *bgp_vrf,
 		return;
 	}
 
-	srv6_locator_free(bgp_vrf->vpn_policy[afi].tovpn_sid_locator);
-	bgp_vrf->vpn_policy[afi].tovpn_sid_locator = NULL;
-
 	if (bgp_vrf->vpn_policy[afi].tovpn_sid) {
 		ctx.vrf_id = bgp_vrf->vrf_id;
 		ctx.behavior = afi == AFI_IP ? ZEBRA_SEG6_LOCAL_ACTION_END_DT4
 					     : ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
-		bgp_zebra_release_srv6_sid(&ctx);
+		bgp_zebra_release_srv6_sid(&ctx, bgp_vrf->vpn_policy[afi].tovpn_sid_locator->name);
 
 		sid_unregister(bgp_vpn, bgp_vrf->vpn_policy[afi].tovpn_sid);
 		XFREE(MTYPE_BGP_SRV6_SID, bgp_vrf->vpn_policy[afi].tovpn_sid);
 	}
 	bgp_vrf->vpn_policy[afi].tovpn_sid_transpose_label = 0;
+
+	srv6_locator_free(bgp_vrf->vpn_policy[afi].tovpn_sid_locator);
+	bgp_vrf->vpn_policy[afi].tovpn_sid_locator = NULL;
 }
 
 void delete_vrf_tovpn_sid_per_vrf(struct bgp *bgp_vpn, struct bgp *bgp_vrf)
@@ -1006,13 +1006,10 @@ void delete_vrf_tovpn_sid_per_vrf(struct bgp *bgp_vpn, struct bgp *bgp_vrf)
 		return;
 	}
 
-	srv6_locator_free(bgp_vrf->tovpn_sid_locator);
-	bgp_vrf->tovpn_sid_locator = NULL;
-
 	if (bgp_vrf->tovpn_sid) {
 		ctx.vrf_id = bgp_vrf->vrf_id;
 		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
-		bgp_zebra_release_srv6_sid(&ctx);
+		bgp_zebra_release_srv6_sid(&ctx, bgp_vrf->tovpn_sid_locator->name);
 
 		sid_unregister(bgp_vpn, bgp_vrf->tovpn_sid);
 		XFREE(MTYPE_BGP_SRV6_SID, bgp_vrf->tovpn_sid);
@@ -1021,6 +1018,9 @@ void delete_vrf_tovpn_sid_per_vrf(struct bgp *bgp_vpn, struct bgp *bgp_vrf)
 		XFREE(MTYPE_BGP_SRV6_SID, bgp_vrf->tovpn_sid_explicit);
 	}
 	bgp_vrf->tovpn_sid_transpose_label = 0;
+
+	srv6_locator_free(bgp_vrf->tovpn_sid_locator);
+	bgp_vrf->tovpn_sid_locator = NULL;
 }
 
 void delete_vrf_tovpn_sid(struct bgp *bgp_vpn, struct bgp *bgp_vrf, afi_t afi)
diff --git a/bgpd/bgp_zebra.c b/bgpd/bgp_zebra.c
index 4b0ee78c12a7..7fa133a5cc07 100644
--- a/bgpd/bgp_zebra.c
+++ b/bgpd/bgp_zebra.c
@@ -4560,19 +4560,20 @@ bool bgp_zebra_request_srv6_sid(const struct srv6_sid_ctx *ctx,
  * to use the SID.
  *
  * @param ctx Context to be associated with the SID to be released
+ * @param locator_name Parent locator of the SID
  */
-void bgp_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx)
+void bgp_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx, const char *locator_name)
 {
 	int ret;
 
-	if (!ctx)
+	if (!ctx || !locator_name)
 		return;
 
 	/*
 	 * Send the Release SRv6 SID request to the SRv6 Manager and check the
 	 * result
 	 */
-	ret = srv6_manager_release_sid(bgp_zclient, ctx);
+	ret = srv6_manager_release_sid(bgp_zclient, ctx, locator_name);
 	if (ret < 0) {
 		zlog_warn("%s: error releasing SRv6 SID!", __func__);
 		return;
diff --git a/bgpd/bgp_zebra.h b/bgpd/bgp_zebra.h
index d4b5eae468e1..dec7b25f8ab9 100644
--- a/bgpd/bgp_zebra.h
+++ b/bgpd/bgp_zebra.h
@@ -129,7 +129,7 @@ extern bool bgp_zebra_request_srv6_sid(const struct srv6_sid_ctx *ctx,
 				       struct in6_addr *sid_value,
 				       const char *locator_name,
 				       uint32_t *sid_func);
-extern void bgp_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx);
+extern void bgp_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx, const char *locator_name);
 
 extern void bgp_zebra_send_nexthop_label(int cmd, mpls_label_t label,
 					 ifindex_t index, vrf_id_t vrfid,
diff --git a/isisd/isis_srv6.c b/isisd/isis_srv6.c
index 720a7a502dd6..aa2cf3ea99be 100644
--- a/isisd/isis_srv6.c
+++ b/isisd/isis_srv6.c
@@ -127,7 +127,7 @@ bool isis_srv6_locator_unset(struct isis_area *area)
 		 * and release/free the SID context if it is not yes by other protocols.
 		 */
 		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END;
-		isis_zebra_release_srv6_sid(&ctx);
+		isis_zebra_release_srv6_sid(&ctx, area->srv6db.config.srv6_locator_name);
 
 		listnode_delete(area->srv6db.srv6_sids, sid);
 		isis_srv6_sid_free(sid);
@@ -143,7 +143,7 @@ bool isis_srv6_locator_unset(struct isis_area *area)
 		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_X;
 		ctx.nh6 = sra->nexthop;
 		ctx.ifindex = sra->adj->circuit->interface->ifindex;
-		isis_zebra_release_srv6_sid(&ctx);
+		isis_zebra_release_srv6_sid(&ctx, area->srv6db.config.srv6_locator_name);
 
 		srv6_endx_sid_del(sra);
 	}
diff --git a/isisd/isis_zebra.c b/isisd/isis_zebra.c
index 70bc48a41e92..48f7560bc755 100644
--- a/isisd/isis_zebra.c
+++ b/isisd/isis_zebra.c
@@ -1478,19 +1478,20 @@ bool isis_zebra_request_srv6_sid(const struct srv6_sid_ctx *ctx,
  * to use the SID.
  *
  * @param ctx Context to be associated with the SID to be released
+ * @param locator_name Parent locator of the SID
  */
-void isis_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx)
+void isis_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx, const char *locator_name)
 {
 	int ret;
 
-	if (!ctx)
+	if (!ctx || !locator_name)
 		return;
 
 	/*
 	 * Send the Release SRv6 SID request to the SRv6 Manager and check the
 	 * result
 	 */
-	ret = srv6_manager_release_sid(isis_zclient, ctx);
+	ret = srv6_manager_release_sid(isis_zclient, ctx, locator_name);
 	if (ret < 0) {
 		zlog_warn("%s: error releasing SRv6 SID!", __func__);
 		return;
diff --git a/isisd/isis_zebra.h b/isisd/isis_zebra.h
index 83a71b7dc907..ded79ccf66f9 100644
--- a/isisd/isis_zebra.h
+++ b/isisd/isis_zebra.h
@@ -73,6 +73,6 @@ extern void isis_zebra_request_srv6_sid_endx(struct isis_adjacency *adj);
 extern bool isis_zebra_request_srv6_sid(const struct srv6_sid_ctx *ctx,
 					struct in6_addr *sid_value,
 					const char *locator_name);
-extern void isis_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx);
+extern void isis_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx, const char *locator_name);
 
 #endif /* _ZEBRA_ISIS_ZEBRA_H */
diff --git a/lib/zclient.c b/lib/zclient.c
index 558626fa351f..173cb5fd7c89 100644
--- a/lib/zclient.c
+++ b/lib/zclient.c
@@ -3583,12 +3583,15 @@ int srv6_manager_get_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx
  *
  * @param zclient Zclient used to connect to SRv6 manager (zebra)
  * @param ctx Context associated with the SRv6 SID to be removed
+ * @param locator_name Parent locator of the SID
  * @result 0 on success, -1 otherwise
  */
-int srv6_manager_release_sid(struct zclient *zclient,
-			     const struct srv6_sid_ctx *ctx)
+int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
+			     const char *locator_name)
 {
 	struct stream *s;
+	uint8_t flags = 0;
+	size_t len;
 	char buf[256];
 
 	if (zclient->sock < 0) {
@@ -3611,6 +3614,18 @@ int srv6_manager_release_sid(struct zclient *zclient,
 	/* Context associated with the SRv6 SID */
 	stream_put(s, ctx, sizeof(struct srv6_sid_ctx));
 
+	/* Flags */
+	if (locator_name)
+		SET_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_HAS_LOCATOR);
+	stream_putc(s, flags);
+
+	/* SRv6 locator */
+	if (CHECK_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_HAS_LOCATOR)) {
+		len = strlen(locator_name);
+		stream_putw(s, len);
+		stream_put(s, locator_name, len);
+	}
+
 	/* Put length at the first point of the stream. */
 	stream_putw_at(s, 0, stream_get_endp(s));
 
diff --git a/lib/zclient.h b/lib/zclient.h
index 49aa531c1b08..b730a58fedbc 100644
--- a/lib/zclient.h
+++ b/lib/zclient.h
@@ -1125,8 +1125,8 @@ extern int srv6_manager_get_sid(struct zclient *zclient,
 				const struct srv6_sid_ctx *ctx,
 				struct in6_addr *sid_value,
 				const char *locator_name, uint32_t *sid_func);
-extern int srv6_manager_release_sid(struct zclient *zclient,
-				    const struct srv6_sid_ctx *ctx);
+extern int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
+				    const char *locator_name);
 
 extern enum zclient_send_status zebra_send_sr_policy(struct zclient *zclient,
 						     int cmd,
diff --git a/staticd/static_zebra.c b/staticd/static_zebra.c
index 82a2d41afa6f..9f462550a77d 100644
--- a/staticd/static_zebra.c
+++ b/staticd/static_zebra.c
@@ -1168,7 +1168,7 @@ extern void static_zebra_release_srv6_sid(struct static_srv6_sid *sid)
 	}
 
 	/* remove the SRv6 SID from the zebra RIB */
-	ret = srv6_manager_release_sid(static_zclient, &ctx);
+	ret = srv6_manager_release_sid(static_zclient, &ctx, sid->locator->name);
 	if (ret == ZCLIENT_SEND_FAILURE)
 		flog_err(EC_LIB_ZAPI_SOCKET, "zclient_send_get_srv6_sid() delete failed: %s",
 			 safe_strerror(errno));
diff --git a/zebra/zapi_msg.c b/zebra/zapi_msg.c
index 20a4c26f6341..4f3727cf42c6 100644
--- a/zebra/zapi_msg.c
+++ b/zebra/zapi_msg.c
@@ -3100,15 +3100,30 @@ static void zread_srv6_manager_release_srv6_sid(struct zserv *client,
 {
 	struct stream *s;
 	struct srv6_sid_ctx ctx = {};
+	char locator[SRV6_LOCNAME_SIZE] = { 0 };
+	uint16_t len;
+	uint8_t flags;
 
 	/* Get input stream */
 	s = msg;
 
 	/* Get data */
 	STREAM_GET(&ctx, s, sizeof(struct srv6_sid_ctx));
+	STREAM_GETC(s, flags);
+	if (CHECK_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_HAS_LOCATOR)) {
+		STREAM_GETW(s, len);
+
+		if (len > SRV6_LOCNAME_SIZE) {
+			zlog_warn("Received locator name length (%u) exceeds maximum length (%u)",
+				  len, SRV6_LOCNAME_SIZE);
+			goto stream_failure;
+		}
+
+		STREAM_GET(locator, s, len);
+	}
 
 	/* Call hook to release a SID using wrapper */
-	srv6_manager_release_sid_call(client, &ctx);
+	srv6_manager_release_sid_call(client, &ctx, locator);
 
 stream_failure:
 	return;
diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 3cfc1c606ff2..2acffc1a6ee8 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -69,7 +69,8 @@ DEFINE_HOOK(srv6_manager_get_sid,
 	     const char *locator_name),
 	    (sid, client, ctx, sid_value, locator_name));
 DEFINE_HOOK(srv6_manager_release_sid,
-	    (struct zserv *client, struct srv6_sid_ctx *ctx), (client, ctx));
+	    (struct zserv * client, struct srv6_sid_ctx *ctx, const char *locator_name),
+	    (client, ctx, locator_name));
 DEFINE_HOOK(srv6_manager_get_locator,
 	    (struct srv6_locator **locator, struct zserv *client,
 	     const char *locator_name),
@@ -115,10 +116,10 @@ void srv6_manager_get_sid_call(struct zebra_srv6_sid **sid,
 		  locator_name);
 }
 
-void srv6_manager_release_sid_call(struct zserv *client,
-				   struct srv6_sid_ctx *ctx)
+void srv6_manager_release_sid_call(struct zserv *client, struct srv6_sid_ctx *ctx,
+				   const char *locator_name)
 {
-	hook_call(srv6_manager_release_sid, client, ctx);
+	hook_call(srv6_manager_release_sid, client, ctx, locator_name);
 }
 
 void srv6_manager_get_locator_call(struct srv6_locator **locator,
@@ -2182,9 +2183,11 @@ static int release_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
  *
  * @param client The client for which the SID has to be released
  * @param ctx Context associated with the SRv6 SID to be released
+ * @param locator Parent locator of the SID
  * @return 0 on success, -1 otherwise
  */
-int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx)
+int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
+		     struct srv6_locator *locator)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	char buf[256];
@@ -2198,6 +2201,13 @@ int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx)
 			   srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx),
 			   client->proto, client->instance);
 
+	if (zctx->sid->locator != locator) {
+		zlog_err("SRv6 SID %pI6 ctx %s is not allocated from the provided locator %s",
+			 &zctx->sid->value, srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx),
+			 locator->name);
+		return -1;
+	}
+
 	/* Ensures the SID is in use by the client */
 	if (!listnode_lookup(zctx->sid->client_list, client)) {
 		flog_err(EC_ZEBRA_SM_DAEMON_MISMATCH, "%s: Daemon mismatch!!",
@@ -2392,7 +2402,7 @@ int release_daemon_srv6_sids(struct zserv *client)
 		if (!listnode_lookup(ctx->sid->client_list, client))
 			continue;
 
-		ret = release_srv6_sid(client, ctx);
+		ret = release_srv6_sid(client, ctx, ctx->sid->locator);
 		if (ret == 0)
 			count++;
 	}
@@ -2408,32 +2418,40 @@ int release_daemon_srv6_sids(struct zserv *client)
  *
  * @param client The client zapi session
  * @param ctx Context associated with the SRv6 SID
+ * @param locator_name Locator from which the SID has to be allocated (for dynamic SID allocation)
  * @return 0 on success, -1 on failure
  */
-static int srv6_manager_release_sid_internal(struct zserv *client,
-					     struct srv6_sid_ctx *ctx)
+static int srv6_manager_release_sid_internal(struct zserv *client, struct srv6_sid_ctx *ctx,
+					     const char *locator_name)
 {
 	int ret = -1;
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_ctx *zctx;
 	struct listnode *node, *nnode;
 	char buf[256];
-	const char *locator_name = NULL;
+	struct srv6_locator *locator = NULL;
 	struct in6_addr sid_value = {};
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: releasing SRv6 SID associated with ctx %s",
 			   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx));
 
+	if (locator_name && locator_name[0] != '\0') {
+		locator = zebra_srv6_locator_lookup(locator_name);
+		if (!locator) {
+			zlog_err("%s: invalid SM request arguments: SRv6 locator '%s' does not exist",
+				 __func__, locator_name);
+			return -1;
+		}
+	}
+
 	/* Lookup Zebra SID context and release it */
 	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, zctx))
 		if (memcmp(&zctx->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0) {
-			if (zctx->sid) {
-				if (zctx->sid->locator)
-					locator_name = (const char *)zctx->sid->locator->name;
+			if (zctx->sid)
 				sid_value = zctx->sid->value;
-			}
-			ret = release_srv6_sid(client, zctx);
+
+			ret = release_srv6_sid(client, zctx, locator);
 			break;
 		}
 
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 1599fd7adfbd..233635ed6f69 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -237,7 +237,8 @@ DECLARE_HOOK(srv6_manager_get_sid,
 	      const char *locator_name),
 	     (sid, client, ctx, sid_value, locator_name));
 DECLARE_HOOK(srv6_manager_release_sid,
-	     (struct zserv *client, struct srv6_sid_ctx *ctx), (client, ctx));
+	     (struct zserv * client, struct srv6_sid_ctx *ctx, const char *locator_name),
+	     (client, ctx, locator_name));
 DECLARE_HOOK(srv6_manager_get_locator,
 	     (struct srv6_locator **locator, struct zserv *client,
 	      const char *locator_name),
@@ -302,8 +303,8 @@ extern void srv6_manager_get_sid_call(struct zebra_srv6_sid **sid,
 				      struct srv6_sid_ctx *ctx,
 				      struct in6_addr *sid_value,
 				      const char *locator_name);
-extern void srv6_manager_release_sid_call(struct zserv *client,
-					  struct srv6_sid_ctx *ctx);
+extern void srv6_manager_release_sid_call(struct zserv *client, struct srv6_sid_ctx *ctx,
+					  const char *locator_name);
 
 extern void srv6_manager_get_locator_call(struct srv6_locator **locator,
 					  struct zserv *client,
@@ -311,8 +312,8 @@ extern void srv6_manager_get_locator_call(struct srv6_locator **locator,
 
 extern int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
 			struct in6_addr *sid_value, const char *locator_name);
-extern int release_srv6_sid(struct zserv *client,
-			    struct zebra_srv6_sid_ctx *zctx);
+extern int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
+			    struct srv6_locator *locator);
 extern int release_daemon_srv6_sids(struct zserv *client);
 extern int srv6_manager_get_sid_response(struct zebra_srv6_sid *sid,
 					 struct zserv *client);

From 1b4cffbd0cbec523f9b306e102fd50df0dfd7c18 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Wed, 14 May 2025 17:54:43 +0000
Subject: [PATCH 02/25] staticd: Fix SID structure pushed to zebra

In order to install a SID into zebra, staticd fills in a seg6local_ctx
data structure and pushes this context to zebra.

Currently, lcnode_func_len is filled with only the node length, while
it should be filled with node length + function length.

This commit fixes the issue by setting these parameters for all SRv6
endpoints.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 staticd/static_zebra.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/staticd/static_zebra.c b/staticd/static_zebra.c
index 9f462550a77d..3c9a6cb8717a 100644
--- a/staticd/static_zebra.c
+++ b/staticd/static_zebra.c
@@ -654,14 +654,10 @@ void static_zebra_srv6_sid_install(struct static_srv6_sid *sid)
 		action = ZEBRA_SEG6_LOCAL_ACTION_END;
 		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
 		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_PSP);
-		ctx.flv.lcblock_len = sid->locator->block_bits_length;
-		ctx.flv.lcnode_func_len = sid->locator->node_bits_length;
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_NEXT_CSID:
 		action = ZEBRA_SEG6_LOCAL_ACTION_END;
 		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
-		ctx.flv.lcblock_len = sid->locator->block_bits_length;
-		ctx.flv.lcnode_func_len = sid->locator->node_bits_length;
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_DT6:
 		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
@@ -772,8 +768,6 @@ void static_zebra_srv6_sid_install(struct static_srv6_sid *sid)
 			return;
 		}
 		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
-		ctx.flv.lcblock_len = sid->locator->block_bits_length;
-		ctx.flv.lcnode_func_len = sid->locator->node_bits_length;
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_PSP_USD:
 	case SRV6_ENDPOINT_BEHAVIOR_END_NEXT_CSID_PSP_USD:
@@ -802,6 +796,9 @@ void static_zebra_srv6_sid_install(struct static_srv6_sid *sid)
 
 	ctx.function_len = sid->addr.prefixlen - (ctx.block_len + ctx.node_len);
 
+	ctx.flv.lcblock_len = sid->locator->block_bits_length;
+	ctx.flv.lcnode_func_len = ctx.node_len + ctx.function_len;
+
 	/* Attach the SID to the SRv6 interface */
 	if (!ifp) {
 		ifp = if_lookup_by_name(DEFAULT_SRV6_IFNAME, VRF_DEFAULT);

From 5f10526e56781cb15d2057f85d5309f0403043b2 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sat, 10 May 2025 10:48:43 +0000
Subject: [PATCH 03/25] *: Support allocation of SRv6 local-only FIB entries

draft-ietf-spring-srv6-srh-compression section #5.3 recommends to program
two entries in the FIB:
* local-only FIB entry, e.g., FCBB:BBBB:E000::/48
* combined FIB entry, e.g., FCBB:BBBB:1:E000::/64

But SID Manager can currently allocate only the combined FIB entry.

This commit extends the API exposed the srv6_manager_get_sid() and
srv6_manager_release_sid() APIs to support the allocation of local-only
FIB entry.

Note that at this time, these APIs are always called with is_localonly=false,
as daemons only support the combined FIB entry.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 bgpd/bgp_zebra.c       |  5 ++--
 isisd/isis_zebra.c     |  4 +--
 lib/zclient.c          | 10 +++++--
 lib/zclient.h          | 10 +++----
 staticd/static_zebra.c |  4 +--
 zebra/zapi_msg.c       | 11 +++++--
 zebra/zebra_srv6.c     | 68 +++++++++++++++++++++---------------------
 zebra/zebra_srv6.h     | 26 ++++++++--------
 8 files changed, 73 insertions(+), 65 deletions(-)

diff --git a/bgpd/bgp_zebra.c b/bgpd/bgp_zebra.c
index 7fa133a5cc07..c21ecfce2abf 100644
--- a/bgpd/bgp_zebra.c
+++ b/bgpd/bgp_zebra.c
@@ -4543,8 +4543,7 @@ bool bgp_zebra_request_srv6_sid(const struct srv6_sid_ctx *ctx,
 	 * Send the Get SRv6 SID request to the SRv6 Manager and check the
 	 * result
 	 */
-	ret = srv6_manager_get_sid(bgp_zclient, ctx, sid_value, locator_name,
-				   sid_func);
+	ret = srv6_manager_get_sid(bgp_zclient, ctx, sid_value, locator_name, sid_func, false);
 	if (ret < 0) {
 		zlog_warn("%s: error getting SRv6 SID!", __func__);
 		return false;
@@ -4573,7 +4572,7 @@ void bgp_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx, const char *loca
 	 * Send the Release SRv6 SID request to the SRv6 Manager and check the
 	 * result
 	 */
-	ret = srv6_manager_release_sid(bgp_zclient, ctx, locator_name);
+	ret = srv6_manager_release_sid(bgp_zclient, ctx, locator_name, false);
 	if (ret < 0) {
 		zlog_warn("%s: error releasing SRv6 SID!", __func__);
 		return;
diff --git a/isisd/isis_zebra.c b/isisd/isis_zebra.c
index 48f7560bc755..1670bc5f2b8a 100644
--- a/isisd/isis_zebra.c
+++ b/isisd/isis_zebra.c
@@ -1462,7 +1462,7 @@ bool isis_zebra_request_srv6_sid(const struct srv6_sid_ctx *ctx,
 	 * Send the Get SRv6 SID request to the SRv6 Manager and check the
 	 * result
 	 */
-	ret = srv6_manager_get_sid(isis_zclient, ctx, sid_value, locator_name, NULL);
+	ret = srv6_manager_get_sid(isis_zclient, ctx, sid_value, locator_name, NULL, false);
 	if (ret < 0) {
 		zlog_warn("%s: error getting SRv6 SID!", __func__);
 		return false;
@@ -1491,7 +1491,7 @@ void isis_zebra_release_srv6_sid(const struct srv6_sid_ctx *ctx, const char *loc
 	 * Send the Release SRv6 SID request to the SRv6 Manager and check the
 	 * result
 	 */
-	ret = srv6_manager_release_sid(isis_zclient, ctx, locator_name);
+	ret = srv6_manager_release_sid(isis_zclient, ctx, locator_name, false);
 	if (ret < 0) {
 		zlog_warn("%s: error releasing SRv6 SID!", __func__);
 		return;
diff --git a/lib/zclient.c b/lib/zclient.c
index 173cb5fd7c89..6dd7d5731ce9 100644
--- a/lib/zclient.c
+++ b/lib/zclient.c
@@ -3526,8 +3526,8 @@ int srv6_manager_get_locator(struct zclient *zclient, const char *locator_name)
  * @result 0 on success, -1 otherwise
  */
 int srv6_manager_get_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
-			 struct in6_addr *sid_value, const char *locator_name,
-			 uint32_t *sid_func)
+			 struct in6_addr *sid_value, const char *locator_name, uint32_t *sid_func,
+			 bool is_localonly)
 {
 	struct stream *s;
 	uint8_t flags = 0;
@@ -3558,6 +3558,8 @@ int srv6_manager_get_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx
 		SET_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_HAS_SID_VALUE);
 	if (locator_name)
 		SET_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_HAS_LOCATOR);
+	if (is_localonly)
+		SET_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_IS_LOCALONLY);
 	stream_putc(s, flags);
 
 	/* SRv6 SID value */
@@ -3587,7 +3589,7 @@ int srv6_manager_get_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx
  * @result 0 on success, -1 otherwise
  */
 int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
-			     const char *locator_name)
+			     const char *locator_name, bool is_localonly)
 {
 	struct stream *s;
 	uint8_t flags = 0;
@@ -3617,6 +3619,8 @@ int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx
 	/* Flags */
 	if (locator_name)
 		SET_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_HAS_LOCATOR);
+	if (is_localonly)
+		SET_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_IS_LOCALONLY);
 	stream_putc(s, flags);
 
 	/* SRv6 locator */
diff --git a/lib/zclient.h b/lib/zclient.h
index b730a58fedbc..71923b58985e 100644
--- a/lib/zclient.h
+++ b/lib/zclient.h
@@ -1114,6 +1114,7 @@ extern int tm_release_table_chunk(struct zclient *zclient, uint32_t start,
 /* Zebra SRv6 Manager flags */
 #define ZAPI_SRV6_MANAGER_SID_FLAG_HAS_SID_VALUE 0x01
 #define ZAPI_SRV6_MANAGER_SID_FLAG_HAS_LOCATOR	 0x02
+#define ZAPI_SRV6_MANAGER_SID_FLAG_IS_LOCALONLY	 0x04
 
 extern int srv6_manager_get_locator_chunk(struct zclient *zclient,
 					  const char *locator_name);
@@ -1121,12 +1122,11 @@ extern int srv6_manager_release_locator_chunk(struct zclient *zclient,
 					      const char *locator_name);
 extern int srv6_manager_get_locator(struct zclient *zclient,
 				    const char *locator_name);
-extern int srv6_manager_get_sid(struct zclient *zclient,
-				const struct srv6_sid_ctx *ctx,
-				struct in6_addr *sid_value,
-				const char *locator_name, uint32_t *sid_func);
+extern int srv6_manager_get_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
+				struct in6_addr *sid_value, const char *locator_name,
+				uint32_t *sid_func, bool is_localonly);
 extern int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
-				    const char *locator_name);
+				    const char *locator_name, bool is_localonly);
 
 extern enum zclient_send_status zebra_send_sr_policy(struct zclient *zclient,
 						     int cmd,
diff --git a/staticd/static_zebra.c b/staticd/static_zebra.c
index 3c9a6cb8717a..d9ec3135a16b 100644
--- a/staticd/static_zebra.c
+++ b/staticd/static_zebra.c
@@ -1074,7 +1074,7 @@ extern void static_zebra_request_srv6_sid(struct static_srv6_sid *sid)
 
 	/* Request SRv6 SID from SID Manager */
 	ret = srv6_manager_get_sid(static_zclient, &ctx, &sid->addr.prefix, sid->locator->name,
-				   NULL);
+				   NULL, false);
 	if (ret < 0)
 		zlog_warn("%s: error getting SRv6 SID!", __func__);
 }
@@ -1165,7 +1165,7 @@ extern void static_zebra_release_srv6_sid(struct static_srv6_sid *sid)
 	}
 
 	/* remove the SRv6 SID from the zebra RIB */
-	ret = srv6_manager_release_sid(static_zclient, &ctx, sid->locator->name);
+	ret = srv6_manager_release_sid(static_zclient, &ctx, sid->locator->name, false);
 	if (ret == ZCLIENT_SEND_FAILURE)
 		flog_err(EC_LIB_ZAPI_SOCKET, "zclient_send_get_srv6_sid() delete failed: %s",
 			 safe_strerror(errno));
diff --git a/zebra/zapi_msg.c b/zebra/zapi_msg.c
index 4f3727cf42c6..454f05598da7 100644
--- a/zebra/zapi_msg.c
+++ b/zebra/zapi_msg.c
@@ -3066,6 +3066,7 @@ static void zread_srv6_manager_get_srv6_sid(struct zserv *client,
 	uint16_t len;
 	struct zebra_srv6_sid *sid = NULL;
 	uint8_t flags;
+	bool is_localonly = false;
 
 	/* Get input stream */
 	s = msg;
@@ -3081,9 +3082,12 @@ static void zread_srv6_manager_get_srv6_sid(struct zserv *client,
 		STREAM_GETW(s, len);
 		STREAM_GET(locator, s, len);
 	}
+	if (CHECK_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_IS_LOCALONLY))
+		is_localonly = true;
+
 
 	/* Call hook to get a SID using wrapper */
-	srv6_manager_get_sid_call(&sid, client, &ctx, sid_value_ptr, locator);
+	srv6_manager_get_sid_call(&sid, client, &ctx, sid_value_ptr, locator, is_localonly);
 
 stream_failure:
 	return;
@@ -3103,6 +3107,7 @@ static void zread_srv6_manager_release_srv6_sid(struct zserv *client,
 	char locator[SRV6_LOCNAME_SIZE] = { 0 };
 	uint16_t len;
 	uint8_t flags;
+	bool is_localonly = false;
 
 	/* Get input stream */
 	s = msg;
@@ -3121,9 +3126,11 @@ static void zread_srv6_manager_release_srv6_sid(struct zserv *client,
 
 		STREAM_GET(locator, s, len);
 	}
+	if (CHECK_FLAG(flags, ZAPI_SRV6_MANAGER_SID_FLAG_IS_LOCALONLY))
+		is_localonly = true;
 
 	/* Call hook to release a SID using wrapper */
-	srv6_manager_release_sid_call(client, &ctx, locator);
+	srv6_manager_release_sid_call(client, &ctx, locator, is_localonly);
 
 stream_failure:
 	return;
diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 2acffc1a6ee8..4a1087bf224d 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -64,13 +64,13 @@ DEFINE_HOOK(srv6_manager_release_chunk,
 	    (client, locator_name, vrf_id));
 
 DEFINE_HOOK(srv6_manager_get_sid,
-	    (struct zebra_srv6_sid **sid, struct zserv *client,
-	     struct srv6_sid_ctx *ctx, struct in6_addr *sid_value,
-	     const char *locator_name),
-	    (sid, client, ctx, sid_value, locator_name));
+	    (struct zebra_srv6_sid **sid, struct zserv *client, struct srv6_sid_ctx *ctx,
+	     struct in6_addr *sid_value, const char *locator_name, bool is_localonly),
+	    (sid, client, ctx, sid_value, locator_name, is_localonly));
 DEFINE_HOOK(srv6_manager_release_sid,
-	    (struct zserv * client, struct srv6_sid_ctx *ctx, const char *locator_name),
-	    (client, ctx, locator_name));
+	    (struct zserv *client, struct srv6_sid_ctx *ctx, const char *locator_name,
+	     bool is_localonly),
+	    (client, ctx, locator_name, is_localonly));
 DEFINE_HOOK(srv6_manager_get_locator,
 	    (struct srv6_locator **locator, struct zserv *client,
 	     const char *locator_name),
@@ -107,19 +107,17 @@ int srv6_manager_client_disconnect_cb(struct zserv *client)
 }
 
 
-void srv6_manager_get_sid_call(struct zebra_srv6_sid **sid,
-			       struct zserv *client, struct srv6_sid_ctx *ctx,
-			       struct in6_addr *sid_value,
-			       const char *locator_name)
+void srv6_manager_get_sid_call(struct zebra_srv6_sid **sid, struct zserv *client,
+			       struct srv6_sid_ctx *ctx, struct in6_addr *sid_value,
+			       const char *locator_name, bool is_localonly)
 {
-	hook_call(srv6_manager_get_sid, sid, client, ctx, sid_value,
-		  locator_name);
+	hook_call(srv6_manager_get_sid, sid, client, ctx, sid_value, locator_name, is_localonly);
 }
 
 void srv6_manager_release_sid_call(struct zserv *client, struct srv6_sid_ctx *ctx,
-				   const char *locator_name)
+				   const char *locator_name, bool is_localonly)
 {
-	hook_call(srv6_manager_release_sid, client, ctx, locator_name);
+	hook_call(srv6_manager_release_sid, client, ctx, locator_name, is_localonly);
 }
 
 void srv6_manager_get_locator_call(struct srv6_locator **locator,
@@ -1484,13 +1482,13 @@ static bool alloc_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
  * @param ctx Context for which the SID has been requested
  * @param sid_value specific SRv6 SID value (i.e. IPv6 address) to be
  * allocated explicitly
+ * @param is_localonly SID is local-only
  *
  * @return 0 if the function returned an existing SID and SID value has not changed,
  * 1 if a new SID has been allocated or the existing SID value has changed, -1 if an error occurred
  */
-static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid,
-				 struct srv6_sid_ctx *ctx,
-				 struct in6_addr *sid_value)
+static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
+				 struct in6_addr *sid_value, bool is_localonly)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_ctx *s = NULL;
@@ -1631,13 +1629,13 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid,
  * @param sid SID returned
  * @param ctx Context for which the SID has been requested
  * @param locator SRv6 locator from which the SID has to be allocated
+ * @param is_localonly SID is local-only
  *
  * @return 0 if the function returned an existing SID and SID value has not changed,
  * 1 if a new SID has been allocated or the existing SID value has changed, -1 if an error occurred
  */
-static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid,
-				struct srv6_sid_ctx *ctx,
-				struct srv6_locator *locator)
+static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
+				struct srv6_locator *locator, bool is_localonly)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_block *block;
@@ -1737,12 +1735,13 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid,
  * @param ctx Context for which the SID has been requested
  * @param sid_value SRv6 SID value to be allocated (for explicit SID allocation)
  * @param locator_name Parent SRv6 locator from which the SID has to be allocated (for dynamic SID allocation)
+ * @param is_localonly SID is local-only
  *
  * @return 0 if the function returned an existing SID and SID value has not changed,
  * 1 if a new SID has been allocated or the existing SID value has changed, -1 if an error occurred
  */
-int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
-		 struct in6_addr *sid_value, const char *locator_name)
+int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx, struct in6_addr *sid_value,
+		 const char *locator_name, bool is_localonly)
 {
 	int ret = -1;
 	struct srv6_locator *locator;
@@ -1813,7 +1812,7 @@ int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
 			return -1;
 		}
 
-		ret = get_srv6_sid_explicit(sid, ctx, sid_value);
+		ret = get_srv6_sid_explicit(sid, ctx, sid_value, is_localonly);
 	} else {
 		/*
 		 * Dynamic SID allocation: allocate any available SID value
@@ -1832,7 +1831,7 @@ int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
 			return -1;
 		}
 
-		ret = get_srv6_sid_dynamic(sid, ctx, locator);
+		ret = get_srv6_sid_dynamic(sid, ctx, locator, is_localonly);
 	}
 
 	return ret;
@@ -2184,10 +2183,11 @@ static int release_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
  * @param client The client for which the SID has to be released
  * @param ctx Context associated with the SRv6 SID to be released
  * @param locator Parent locator of the SID
+ * @param is_localonly SID is local-only
  * @return 0 on success, -1 otherwise
  */
 int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
-		     struct srv6_locator *locator)
+		     struct srv6_locator *locator, bool is_localonly)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	char buf[256];
@@ -2310,14 +2310,13 @@ static int srv6_manager_get_srv6_locator_internal(struct srv6_locator **locator,
  * @param sid_value SID value (i.e., IPv6 address) that has to be assigned to the SID
  *                  (for explicit SID allocation)
  * @param locator_name Locator from which the SID has to be allocated (for dynamic SID allocation)
+ * @param is_localonly SID is local-only
  *
  * @return 0 on success, -1 otherwise
  */
-static int srv6_manager_get_sid_internal(struct zebra_srv6_sid **sid,
-					 struct zserv *client,
-					 struct srv6_sid_ctx *ctx,
-					 struct in6_addr *sid_value,
-					 const char *locator_name)
+static int srv6_manager_get_sid_internal(struct zebra_srv6_sid **sid, struct zserv *client,
+					 struct srv6_sid_ctx *ctx, struct in6_addr *sid_value,
+					 const char *locator_name, bool is_localonly)
 {
 	int ret = -1;
 	struct listnode *node;
@@ -2329,7 +2328,7 @@ static int srv6_manager_get_sid_internal(struct zebra_srv6_sid **sid,
 			   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx),
 			   sid_value ? sid_value : &in6addr_any, locator_name);
 
-	ret = get_srv6_sid(sid, ctx, sid_value, locator_name);
+	ret = get_srv6_sid(sid, ctx, sid_value, locator_name, is_localonly);
 	if (ret < 0) {
 		zlog_warn("%s: not got SRv6 SID for ctx %s, sid_value=%pI6, locator_name=%s",
 			  __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx),
@@ -2402,7 +2401,7 @@ int release_daemon_srv6_sids(struct zserv *client)
 		if (!listnode_lookup(ctx->sid->client_list, client))
 			continue;
 
-		ret = release_srv6_sid(client, ctx, ctx->sid->locator);
+		ret = release_srv6_sid(client, ctx, ctx->sid->locator, false);
 		if (ret == 0)
 			count++;
 	}
@@ -2419,10 +2418,11 @@ int release_daemon_srv6_sids(struct zserv *client)
  * @param client The client zapi session
  * @param ctx Context associated with the SRv6 SID
  * @param locator_name Locator from which the SID has to be allocated (for dynamic SID allocation)
+ * @param is_localonly SID is local-only
  * @return 0 on success, -1 on failure
  */
 static int srv6_manager_release_sid_internal(struct zserv *client, struct srv6_sid_ctx *ctx,
-					     const char *locator_name)
+					     const char *locator_name, bool is_localonly)
 {
 	int ret = -1;
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
@@ -2451,7 +2451,7 @@ static int srv6_manager_release_sid_internal(struct zserv *client, struct srv6_s
 			if (zctx->sid)
 				sid_value = zctx->sid->value;
 
-			ret = release_srv6_sid(client, zctx, locator);
+			ret = release_srv6_sid(client, zctx, locator, is_localonly);
 			break;
 		}
 
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 233635ed6f69..0ceb1589a325 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -232,13 +232,13 @@ DECLARE_HOOK(srv6_manager_release_chunk,
 	     (client, locator_name, vrf_id));
 
 DECLARE_HOOK(srv6_manager_get_sid,
-	     (struct zebra_srv6_sid **sid, struct zserv *client,
-	      struct srv6_sid_ctx *ctx, struct in6_addr *sid_value,
-	      const char *locator_name),
-	     (sid, client, ctx, sid_value, locator_name));
+	     (struct zebra_srv6_sid **sid, struct zserv *client, struct srv6_sid_ctx *ctx,
+	      struct in6_addr *sid_value, const char *locator_name, bool is_localonly),
+	     (sid, client, ctx, sid_value, locator_name, is_localonly));
 DECLARE_HOOK(srv6_manager_release_sid,
-	     (struct zserv * client, struct srv6_sid_ctx *ctx, const char *locator_name),
-	     (client, ctx, locator_name));
+	     (struct zserv *client, struct srv6_sid_ctx *ctx, const char *locator_name,
+	      bool is_localonly),
+	     (client, ctx, locator_name, is_localonly));
 DECLARE_HOOK(srv6_manager_get_locator,
 	     (struct srv6_locator **locator, struct zserv *client,
 	      const char *locator_name),
@@ -298,22 +298,20 @@ zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx, struct in6_addr *sid_value,
 extern void zebra_srv6_sid_free(struct zebra_srv6_sid *sid);
 extern void delete_zebra_srv6_sid(void *val);
 
-extern void srv6_manager_get_sid_call(struct zebra_srv6_sid **sid,
-				      struct zserv *client,
-				      struct srv6_sid_ctx *ctx,
-				      struct in6_addr *sid_value,
-				      const char *locator_name);
+extern void srv6_manager_get_sid_call(struct zebra_srv6_sid **sid, struct zserv *client,
+				      struct srv6_sid_ctx *ctx, struct in6_addr *sid_value,
+				      const char *locator_name, bool is_localonly);
 extern void srv6_manager_release_sid_call(struct zserv *client, struct srv6_sid_ctx *ctx,
-					  const char *locator_name);
+					  const char *locator_name, bool is_localonly);
 
 extern void srv6_manager_get_locator_call(struct srv6_locator **locator,
 					  struct zserv *client,
 					  const char *locator_name);
 
 extern int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
-			struct in6_addr *sid_value, const char *locator_name);
+			struct in6_addr *sid_value, const char *locator_name, bool is_localonly);
 extern int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
-			    struct srv6_locator *locator);
+			    struct srv6_locator *locator, bool is_localonly);
 extern int release_daemon_srv6_sids(struct zserv *client);
 extern int srv6_manager_get_sid_response(struct zebra_srv6_sid *sid,
 					 struct zserv *client);

From d64390a1255d2e7a727599a0c094e082b6bc794f Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sat, 17 May 2025 08:43:43 +0000
Subject: [PATCH 04/25] staticd: Add support for local-only SIDs

Extend staticd to support local-only SIDs.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 lib/zclient.c          |  2 ++
 staticd/static_zebra.c | 22 ++++++++++++++++++++--
 zebra/zebra_srv6.c     |  1 +
 3 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/lib/zclient.c b/lib/zclient.c
index 6dd7d5731ce9..29e2e60b738c 100644
--- a/lib/zclient.c
+++ b/lib/zclient.c
@@ -3523,6 +3523,7 @@ int srv6_manager_get_locator(struct zclient *zclient, const char *locator_name)
  * @param sid_value SRv6 SID value for explicit SID allocation
  * @param locator_name Name of the parent locator for dynamic SID allocation
  * @param sid_func SID function assigned by the SRv6 Manager
+ * @param is_localonly SID is local-only
  * @result 0 on success, -1 otherwise
  */
 int srv6_manager_get_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
@@ -3586,6 +3587,7 @@ int srv6_manager_get_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx
  * @param zclient Zclient used to connect to SRv6 manager (zebra)
  * @param ctx Context associated with the SRv6 SID to be removed
  * @param locator_name Parent locator of the SID
+ * @param is_localonly SID is local-only
  * @result 0 on success, -1 otherwise
  */
 int srv6_manager_release_sid(struct zclient *zclient, const struct srv6_sid_ctx *ctx,
diff --git a/staticd/static_zebra.c b/staticd/static_zebra.c
index d9ec3135a16b..b02156c847ec 100644
--- a/staticd/static_zebra.c
+++ b/staticd/static_zebra.c
@@ -979,6 +979,23 @@ static bool static_zebra_sid_locator_block_check(struct static_srv6_sid *sid)
 	return true;
 }
 
+static bool is_srv6_sid_localonly(const struct static_srv6_sid *sid)
+{
+	struct prefix_ipv6 block = {};
+	struct prefix_ipv6 locator = {};
+
+	block = sid->locator->prefix;
+	block.prefixlen = sid->locator->block_bits_length;
+	apply_mask(&block);
+
+	locator = sid->locator->prefix;
+
+	if (prefix_match(&block, &sid->addr) && !prefix_match(&locator, &sid->addr))
+		return true;
+
+	return false;
+}
+
 extern void static_zebra_request_srv6_sid(struct static_srv6_sid *sid)
 {
 	struct srv6_sid_ctx ctx = {};
@@ -1074,7 +1091,7 @@ extern void static_zebra_request_srv6_sid(struct static_srv6_sid *sid)
 
 	/* Request SRv6 SID from SID Manager */
 	ret = srv6_manager_get_sid(static_zclient, &ctx, &sid->addr.prefix, sid->locator->name,
-				   NULL, false);
+				   NULL, is_srv6_sid_localonly(sid));
 	if (ret < 0)
 		zlog_warn("%s: error getting SRv6 SID!", __func__);
 }
@@ -1165,7 +1182,8 @@ extern void static_zebra_release_srv6_sid(struct static_srv6_sid *sid)
 	}
 
 	/* remove the SRv6 SID from the zebra RIB */
-	ret = srv6_manager_release_sid(static_zclient, &ctx, sid->locator->name, false);
+	ret = srv6_manager_release_sid(static_zclient, &ctx, sid->locator->name,
+				       is_srv6_sid_localonly(sid));
 	if (ret == ZCLIENT_SEND_FAILURE)
 		flog_err(EC_LIB_ZAPI_SOCKET, "zclient_send_get_srv6_sid() delete failed: %s",
 			 safe_strerror(errno));
diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 4a1087bf224d..7ec345660eb0 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -944,6 +944,7 @@ void zebra_srv6_encap_src_addr_unset(void)
  * @param sid_value SRv6 SID address returned
  * @param locator Parent locator of the SRv6 SID
  * @param sid_func Function part of the SID
+ * @param is_localonly SID is local-only
  * @return True if success, False otherwise
  */
 static bool zebra_srv6_sid_compose(struct in6_addr *sid_value,

From d75f0740c5ac8875fc1d6585aa8c728a41a5a881 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Wed, 25 Jun 2025 11:44:44 +0000
Subject: [PATCH 05/25] zebra: Add support for block-len 48, node-len 16,
 func-len 16

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 lib/command.h          |   1 +
 vtysh/vtysh.c          |  20 ++++++
 zebra/zebra_srv6.c     |  33 ++++++++++
 zebra/zebra_srv6.h     |  13 ++++
 zebra/zebra_srv6_vty.c | 139 +++++++++++++++++++++++++++++++++++++----
 5 files changed, 193 insertions(+), 13 deletions(-)

diff --git a/lib/command.h b/lib/command.h
index 282eca94913c..ea08a74d6ad8 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -159,6 +159,7 @@ enum node_type {
 	SRV6_ENCAP_NODE,		 /* SRv6 encapsulation node */
 	SRV6_SID_FORMATS_NODE,		 /* SRv6 SID formats config node */
 	SRV6_SID_FORMAT_USID_F3216_NODE,		 /* SRv6 uSID f3216 format config node */
+	SRV6_SID_FORMAT_USID_F4816_NODE,		 /* SRv6 uSID f4816 format config node */
 	SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE,		 /* SRv6 uncompressed f4024 format config node */
 	VTY_NODE,		 /* Vty node. */
 	FPM_NODE,		 /* Dataplane FPM node. */
diff --git a/vtysh/vtysh.c b/vtysh/vtysh.c
index 5a19af1f74ca..1f21f2cda9f4 100644
--- a/vtysh/vtysh.c
+++ b/vtysh/vtysh.c
@@ -1354,6 +1354,11 @@ static struct cmd_node srv6_sid_format_usid_f3216_node = {
 	.prompt = "%s(config-srv6-format)# "
 };
 
+static struct cmd_node srv6_sid_format_usid_f4816_node = { .name = "srv6-format-usid-f4816",
+							   .node = SRV6_SID_FORMAT_USID_F4816_NODE,
+							   .parent_node = SRV6_SID_FORMATS_NODE,
+							   .prompt = "%s(config-srv6-format)# " };
+
 static struct cmd_node srv6_sid_format_uncompressed_f4024_node = {
 	.name = "srv6-format-uncompressed-f4024",
 	.node = SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE,
@@ -1757,6 +1762,15 @@ DEFUNSH(VTYSH_ZEBRA, srv6_sid_format_f3216_usid, srv6_sid_format_f3216_usid_cmd,
 	return CMD_SUCCESS;
 }
 
+DEFUNSH(VTYSH_ZEBRA, srv6_sid_format_f4816_usid, srv6_sid_format_f4816_usid_cmd,
+	"format usid-f4816",
+	"Configure SRv6 SID format\n"
+	"Configure the uSID f4816 format\n")
+{
+	vty->node = SRV6_SID_FORMAT_USID_F4816_NODE;
+	return CMD_SUCCESS;
+}
+
 DEFUNSH(VTYSH_ZEBRA, srv6_sid_format_f4024_uncompressed, srv6_sid_format_f4024_uncompressed_cmd,
 	"format uncompressed-f4024",
 	"Configure SRv6 SID format\n"
@@ -2683,6 +2697,7 @@ DEFUNSH(VTYSH_ZEBRA, exit_srv6_sid_format, exit_srv6_sid_format_cmd,
 	"exit", "Exit from SRv6 SID format configuration mode\n")
 {
 	if (vty->node == SRV6_SID_FORMAT_USID_F3216_NODE ||
+	    vty->node == SRV6_SID_FORMAT_USID_F4816_NODE ||
 	    vty->node == SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE)
 		vty->node = SRV6_SID_FORMATS_NODE;
 	return CMD_SUCCESS;
@@ -5114,6 +5129,7 @@ void vtysh_init_vty(void)
 	install_node(&srv6_encap_node);
 	install_node(&srv6_sid_formats_node);
 	install_node(&srv6_sid_format_usid_f3216_node);
+	install_node(&srv6_sid_format_usid_f4816_node);
 	install_node(&srv6_sid_format_uncompressed_f4024_node);
 
 	vtysh_init_cmd();
@@ -5572,6 +5588,7 @@ void vtysh_init_vty(void)
 	install_element(SRV6_ENCAP_NODE, &vtysh_end_all_cmd);
 
 	install_element(SRV6_SID_FORMATS_NODE, &srv6_sid_format_f3216_usid_cmd);
+	install_element(SRV6_SID_FORMATS_NODE, &srv6_sid_format_f4816_usid_cmd);
 	install_element(SRV6_SID_FORMATS_NODE,
 			&srv6_sid_format_f4024_uncompressed_cmd);
 	install_element(SRV6_SID_FORMATS_NODE, &exit_srv6_sid_formats_cmd);
@@ -5581,6 +5598,9 @@ void vtysh_init_vty(void)
 			&exit_srv6_sid_format_cmd);
 	install_element(SRV6_SID_FORMAT_USID_F3216_NODE, &vtysh_end_all_cmd);
 
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &exit_srv6_sid_format_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &vtysh_end_all_cmd);
+
 	install_element(SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE,
 			&exit_srv6_sid_format_cmd);
 	install_element(SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE,
diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 7ec345660eb0..89d8f23baa14 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -354,6 +354,34 @@ static struct srv6_sid_format *create_srv6_sid_format_usid_f3216(void)
 	return format;
 }
 
+/*
+ * Helper function to create the SRv6 compressed format `usid-f4816`.
+ */
+static struct srv6_sid_format *create_srv6_sid_format_usid_f4816(void)
+{
+	struct srv6_sid_format *format = NULL;
+
+	format = srv6_sid_format_alloc(SRV6_SID_FORMAT_USID_F4816_NAME);
+
+	format->type = SRV6_SID_FORMAT_TYPE_USID;
+
+	/* Define block/node/function length */
+	format->block_len = SRV6_SID_FORMAT_USID_F4816_BLOCK_LEN;
+	format->node_len = SRV6_SID_FORMAT_USID_F4816_NODE_LEN;
+	format->function_len = SRV6_SID_FORMAT_USID_F4816_FUNCTION_LEN;
+	format->argument_len = SRV6_SID_FORMAT_USID_F4816_ARGUMENT_LEN;
+
+	/* Define the ranges from which the SID function can be allocated */
+	format->config.usid.lib_start = SRV6_SID_FORMAT_USID_F4816_LIB_START;
+	format->config.usid.elib_start = SRV6_SID_FORMAT_USID_F4816_ELIB_START;
+	format->config.usid.elib_end = SRV6_SID_FORMAT_USID_F4816_ELIB_END;
+	format->config.usid.wlib_start = SRV6_SID_FORMAT_USID_F4816_WLIB_START;
+	format->config.usid.wlib_end = SRV6_SID_FORMAT_USID_F4816_WLIB_END;
+	format->config.usid.ewlib_start = SRV6_SID_FORMAT_USID_F4816_EWLIB_START;
+
+	return format;
+}
+
 /*
  * Helper function to create the SRv6 uncompressed format.
  */
@@ -710,6 +738,7 @@ struct zebra_srv6 *zebra_srv6_get_default(void)
 {
 	static bool first_execution = true;
 	struct srv6_sid_format *format_usidf3216;
+	struct srv6_sid_format *format_usidf4816;
 	struct srv6_sid_format *format_uncompressed;
 
 	if (first_execution) {
@@ -724,6 +753,10 @@ struct zebra_srv6 *zebra_srv6_get_default(void)
 		format_usidf3216 = create_srv6_sid_format_usid_f3216();
 		srv6_sid_format_register(format_usidf3216);
 
+		/* Create SID format `usid-f4816` */
+		format_usidf4816 = create_srv6_sid_format_usid_f4816();
+		srv6_sid_format_register(format_usidf4816);
+
 		/* Create SID format `uncompressed` */
 		format_uncompressed = create_srv6_sid_format_uncompressed();
 		srv6_sid_format_register(format_uncompressed);
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 0ceb1589a325..a056dcadaf8e 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -29,6 +29,19 @@
 #define SRV6_SID_FORMAT_USID_F3216_WLIB_END	0xFFF7
 #define SRV6_SID_FORMAT_USID_F3216_EWLIB_START	0xFFF7
 
+/* Default config for SRv6 SID `usid-f4816` format */
+#define SRV6_SID_FORMAT_USID_F4816_NAME		"usid-f4816"
+#define SRV6_SID_FORMAT_USID_F4816_BLOCK_LEN	48
+#define SRV6_SID_FORMAT_USID_F4816_NODE_LEN	16
+#define SRV6_SID_FORMAT_USID_F4816_FUNCTION_LEN 16
+#define SRV6_SID_FORMAT_USID_F4816_ARGUMENT_LEN 0
+#define SRV6_SID_FORMAT_USID_F4816_LIB_START	0xE000
+#define SRV6_SID_FORMAT_USID_F4816_ELIB_START	0xFE00
+#define SRV6_SID_FORMAT_USID_F4816_ELIB_END	0xFEFF
+#define SRV6_SID_FORMAT_USID_F4816_WLIB_START	0xFFF0
+#define SRV6_SID_FORMAT_USID_F4816_WLIB_END	0xFFF7
+#define SRV6_SID_FORMAT_USID_F4816_EWLIB_START	0xFFF7
+
 /* Default config for SRv6 SID `uncompressed` format */
 #define SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NAME			"uncompressed-f4024"
 #define SRV6_SID_FORMAT_UNCOMPRESSED_F4024_BLOCK_LEN		40
diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index f43ffd1705d7..c457f91fada2 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -83,6 +83,11 @@ static struct cmd_node srv6_sid_format_usid_f3216_node = {
 	.prompt = "%s(config-srv6-format)# "
 };
 
+static struct cmd_node srv6_sid_format_usid_f4816_node = { .name = "srv6-format-usid-f4816",
+							   .node = SRV6_SID_FORMAT_USID_F4816_NODE,
+							   .parent_node = SRV6_SID_FORMATS_NODE,
+							   .prompt = "%s(config-srv6-format)# " };
+
 static struct cmd_node srv6_sid_format_uncompressed_f4024_node = {
 	.name = "srv6-format-uncompressed-f4024",
 	.node = SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE,
@@ -825,6 +830,9 @@ DEFPY (locator_prefix,
 			expected_prefixlen =
 				SRV6_SID_FORMAT_USID_F3216_BLOCK_LEN +
 				SRV6_SID_FORMAT_USID_F3216_NODE_LEN;
+		else if (strmatch(format->name, SRV6_SID_FORMAT_USID_F4816_NAME))
+			expected_prefixlen = SRV6_SID_FORMAT_USID_F4816_BLOCK_LEN +
+					     SRV6_SID_FORMAT_USID_F4816_NODE_LEN;
 		else if (strmatch(format->name,
 				  SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NAME))
 			expected_prefixlen =
@@ -982,9 +990,10 @@ DEFPY (locator_flavor_psp,
 
 DEFPY(locator_sid_format,
       locator_sid_format_cmd,
-      "format <usid-f3216|uncompressed-f4024>$format",
+      "format <usid-f3216|usid-f4816|uncompressed-f4024>$format",
       "Configure SRv6 SID format\n"
       "Specify usid-f3216 format\n"
+      "Specify usid-f4816 format\n"
       "Specify uncompressed-f4024 format\n")
 {
 	VTY_DECLVAR_CONTEXT(srv6_locator, locator);
@@ -995,6 +1004,9 @@ DEFPY(locator_sid_format,
 	if (strmatch(format, SRV6_SID_FORMAT_USID_F3216_NAME))
 		expected_prefixlen = SRV6_SID_FORMAT_USID_F3216_BLOCK_LEN +
 				     SRV6_SID_FORMAT_USID_F3216_NODE_LEN;
+	else if (strmatch(format, SRV6_SID_FORMAT_USID_F4816_NAME))
+		expected_prefixlen = SRV6_SID_FORMAT_USID_F4816_BLOCK_LEN +
+				     SRV6_SID_FORMAT_USID_F4816_NODE_LEN;
 	else if (strmatch(format, SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NAME))
 		expected_prefixlen =
 			SRV6_SID_FORMAT_UNCOMPRESSED_F4024_BLOCK_LEN +
@@ -1127,6 +1139,46 @@ DEFUN(no_srv6_sid_format_f3216_usid,
 	return CMD_SUCCESS;
 }
 
+DEFUN_NOSH (srv6_sid_format_f4816_usid,
+            srv6_sid_format_f4816_usid_cmd,
+            "format usid-f4816",
+            "Configure SRv6 SID format\n"
+            "Configure the uSID f4816 format\n")
+{
+	struct srv6_sid_format *format;
+
+	format = srv6_sid_format_lookup(SRV6_SID_FORMAT_USID_F4816_NAME);
+	assert(format);
+
+	VTY_PUSH_CONTEXT(SRV6_SID_FORMAT_USID_F4816_NODE, format);
+	return CMD_SUCCESS;
+}
+
+DEFUN(no_srv6_sid_format_f4816_usid,
+      no_srv6_sid_format_f4816_usid_cmd,
+      "no format usid-f4816",
+      NO_STR
+      "Configure SRv6 SID format\n"
+      "Configure the uSID f4816 format\n")
+{
+	struct srv6_sid_format *format;
+
+	format = srv6_sid_format_lookup(SRV6_SID_FORMAT_USID_F4816_NAME);
+	assert(format);
+
+	format->config.usid.lib_start = SRV6_SID_FORMAT_USID_F4816_LIB_START;
+	format->config.usid.elib_start = SRV6_SID_FORMAT_USID_F4816_ELIB_START;
+	format->config.usid.elib_end = SRV6_SID_FORMAT_USID_F4816_ELIB_END;
+	format->config.usid.wlib_start = SRV6_SID_FORMAT_USID_F4816_WLIB_START;
+	format->config.usid.wlib_end = SRV6_SID_FORMAT_USID_F4816_WLIB_END;
+	format->config.usid.ewlib_start = SRV6_SID_FORMAT_USID_F4816_EWLIB_START;
+
+	/* Notify zclients that the format has changed */
+	zebra_srv6_sid_format_changed_cb(format);
+
+	return CMD_SUCCESS;
+}
+
 DEFUN_NOSH (srv6_sid_format_f4024_uncompressed,
             srv6_sid_format_uncompressed_cmd,
             "format uncompressed-f4024",
@@ -1193,6 +1245,8 @@ DEFPY(no_srv6_sid_format_usid_lib,
 	if (strmatch(format->name, SRV6_SID_FORMAT_USID_F3216_NAME))
 		format->config.usid.lib_start =
 			SRV6_SID_FORMAT_USID_F3216_LIB_START;
+	else if (strmatch(format->name, SRV6_SID_FORMAT_USID_F4816_NAME))
+		format->config.usid.lib_start = SRV6_SID_FORMAT_USID_F4816_LIB_START;
 	else
 		assert(0);
 
@@ -1241,6 +1295,9 @@ DEFPY(no_srv6_sid_format_usid_lib_explicit,
 			SRV6_SID_FORMAT_USID_F3216_ELIB_START;
 		format->config.usid.elib_end =
 			SRV6_SID_FORMAT_USID_F3216_ELIB_END;
+	} else if (strmatch(format->name, SRV6_SID_FORMAT_USID_F4816_NAME)) {
+		format->config.usid.elib_start = SRV6_SID_FORMAT_USID_F4816_ELIB_START;
+		format->config.usid.elib_end = SRV6_SID_FORMAT_USID_F4816_ELIB_END;
 	} else {
 		assert(0);
 	}
@@ -1288,6 +1345,10 @@ DEFPY(no_srv6_sid_format_usid_wlib,
 			SRV6_SID_FORMAT_USID_F3216_WLIB_START;
 		format->config.usid.wlib_end =
 			SRV6_SID_FORMAT_USID_F3216_WLIB_END;
+	}
+	if (strmatch(format->name, SRV6_SID_FORMAT_USID_F4816_NAME)) {
+		format->config.usid.wlib_start = SRV6_SID_FORMAT_USID_F4816_WLIB_START;
+		format->config.usid.wlib_end = SRV6_SID_FORMAT_USID_F4816_WLIB_END;
 	} else {
 		assert(0);
 	}
@@ -1330,6 +1391,8 @@ DEFPY(no_srv6_sid_format_usid_wide_lib_explicit,
 	if (strmatch(format->name, SRV6_SID_FORMAT_USID_F3216_NAME))
 		format->config.usid.ewlib_start =
 			SRV6_SID_FORMAT_USID_F3216_EWLIB_START;
+	else if (strmatch(format->name, SRV6_SID_FORMAT_USID_F4816_NAME))
+		format->config.usid.ewlib_start = SRV6_SID_FORMAT_USID_F4816_EWLIB_START;
 	else
 		assert(0);
 
@@ -1383,8 +1446,7 @@ static bool has_default_sid_format_config(struct srv6_sid_format *format)
 {
 	bool has_default_config = true;
 
-	switch (format->type) {
-	case SRV6_SID_FORMAT_TYPE_USID:
+	if (strmatch(format->name, SRV6_SID_FORMAT_USID_F3216_NAME)) {
 		if (format->config.usid.lib_start != SRV6_SID_FORMAT_USID_F3216_LIB_START)
 			has_default_config = false;
 
@@ -1402,18 +1464,28 @@ static bool has_default_sid_format_config(struct srv6_sid_format *format)
 
 		if (format->config.usid.ewlib_start != SRV6_SID_FORMAT_USID_F3216_EWLIB_START)
 			has_default_config = false;
+	} else if (strmatch(format->name, SRV6_SID_FORMAT_USID_F4816_NAME)) {
+		if (format->config.usid.lib_start != SRV6_SID_FORMAT_USID_F4816_LIB_START)
+			has_default_config = false;
 
-		break;
+		if (format->config.usid.elib_start != SRV6_SID_FORMAT_USID_F4816_ELIB_START)
+			has_default_config = false;
 
-	case SRV6_SID_FORMAT_TYPE_UNCOMPRESSED:
-		if (format->config.uncompressed.explicit_start !=
-		    SRV6_SID_FORMAT_UNCOMPRESSED_F4024_EXPLICIT_RANGE_START)
+		if (format->config.usid.elib_end != SRV6_SID_FORMAT_USID_F4816_ELIB_END)
 			has_default_config = false;
 
-		break;
+		if (format->config.usid.wlib_start != SRV6_SID_FORMAT_USID_F4816_WLIB_START)
+			has_default_config = false;
 
-	case SRV6_SID_FORMAT_TYPE_UNSPEC:
-		break;
+		if (format->config.usid.wlib_end != SRV6_SID_FORMAT_USID_F4816_WLIB_END)
+			has_default_config = false;
+
+		if (format->config.usid.ewlib_start != SRV6_SID_FORMAT_USID_F4816_EWLIB_START)
+			has_default_config = false;
+	} else if (strmatch(format->name, SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NAME)) {
+		if (format->config.uncompressed.explicit_start !=
+		    SRV6_SID_FORMAT_UNCOMPRESSED_F4024_EXPLICIT_RANGE_START)
+			has_default_config = false;
 	}
 
 	return has_default_config;
@@ -1500,14 +1572,14 @@ static int zebra_sr_config(struct vty *vty)
 					/* This SID format is using the default config, skipping */
 					continue;
 
-				if (format->type == SRV6_SID_FORMAT_TYPE_UNCOMPRESSED) {
+				if (strmatch(format->name,
+					     SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NAME)) {
 					vty_out(vty, "   format %s\n", format->name);
 					if (format->config.uncompressed.explicit_start !=
 					    SRV6_SID_FORMAT_UNCOMPRESSED_F4024_EXPLICIT_RANGE_START)
 						vty_out(vty, "    explicit start %u\n",
 							format->config.uncompressed.explicit_start);
-				}
-				if (format->type == SRV6_SID_FORMAT_TYPE_USID) {
+				} else if (strmatch(format->name, SRV6_SID_FORMAT_USID_F3216_NAME)) {
 					vty_out(vty, "   format %s\n", format->name);
 					if (format->config.usid.lib_start !=
 					    SRV6_SID_FORMAT_USID_F3216_LIB_START)
@@ -1534,6 +1606,33 @@ static int zebra_sr_config(struct vty *vty)
 						vty_out(vty,
 							"    wide-local-id-block explicit start %u\n",
 							format->config.usid.ewlib_start);
+				} else if (strmatch(format->name, SRV6_SID_FORMAT_USID_F4816_NAME)) {
+					vty_out(vty, "   format %s\n", format->name);
+					if (format->config.usid.lib_start !=
+					    SRV6_SID_FORMAT_USID_F4816_LIB_START)
+						vty_out(vty, "    local-id-block start %u\n",
+							format->config.usid.lib_start);
+					if (format->config.usid.elib_start !=
+						    SRV6_SID_FORMAT_USID_F4816_ELIB_START ||
+					    format->config.usid.elib_end !=
+						    SRV6_SID_FORMAT_USID_F4816_ELIB_END)
+						vty_out(vty,
+							"    local-id-block explicit start %u end %u\n",
+							format->config.usid.elib_start,
+							format->config.usid.elib_end);
+					if (format->config.usid.wlib_start !=
+						    SRV6_SID_FORMAT_USID_F4816_WLIB_START ||
+					    format->config.usid.wlib_end !=
+						    SRV6_SID_FORMAT_USID_F4816_WLIB_END)
+						vty_out(vty,
+							"    wide-local-id-block start %u end %u\n",
+							format->config.usid.wlib_start,
+							format->config.usid.wlib_end);
+					if (format->config.usid.ewlib_start !=
+					    SRV6_SID_FORMAT_USID_F4816_EWLIB_START)
+						vty_out(vty,
+							"    wide-local-id-block explicit start %u\n",
+							format->config.usid.ewlib_start);
 				}
 				vty_out(vty, "   exit\n");
 				vty_out(vty, "   !\n");
@@ -1561,6 +1660,7 @@ void zebra_srv6_vty_init(void)
 	install_node(&srv6_encap_node);
 	install_node(&srv6_sid_formats_node);
 	install_node(&srv6_sid_format_usid_f3216_node);
+	install_node(&srv6_sid_format_usid_f4816_node);
 	install_node(&srv6_sid_format_uncompressed_f4024_node);
 	install_default(SEGMENT_ROUTING_NODE);
 	install_default(SRV6_NODE);
@@ -1569,6 +1669,7 @@ void zebra_srv6_vty_init(void)
 	install_default(SRV6_ENCAP_NODE);
 	install_default(SRV6_SID_FORMATS_NODE);
 	install_default(SRV6_SID_FORMAT_USID_F3216_NODE);
+	install_default(SRV6_SID_FORMAT_USID_F4816_NODE);
 	install_default(SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE);
 
 	/* Command for change node */
@@ -1581,10 +1682,12 @@ void zebra_srv6_vty_init(void)
 	install_element(SRV6_LOCS_NODE, &srv6_locator_cmd);
 	install_element(SRV6_LOCS_NODE, &no_srv6_locator_cmd);
 	install_element(SRV6_SID_FORMATS_NODE, &srv6_sid_format_f3216_usid_cmd);
+	install_element(SRV6_SID_FORMATS_NODE, &srv6_sid_format_f4816_usid_cmd);
 	install_element(SRV6_SID_FORMATS_NODE,
 			&srv6_sid_format_uncompressed_cmd);
 	install_element(SRV6_SID_FORMATS_NODE,
 			&no_srv6_sid_format_f3216_usid_cmd);
+	install_element(SRV6_SID_FORMATS_NODE, &no_srv6_sid_format_f4816_usid_cmd);
 	install_element(SRV6_SID_FORMATS_NODE,
 			&no_srv6_sid_format_f4024_uncompressed_cmd);
 
@@ -1612,6 +1715,16 @@ void zebra_srv6_vty_init(void)
 			&srv6_sid_format_usid_wide_lib_explicit_cmd);
 	install_element(SRV6_SID_FORMAT_USID_F3216_NODE,
 			&no_srv6_sid_format_usid_wide_lib_explicit_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &srv6_sid_format_usid_lib_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &no_srv6_sid_format_usid_lib_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &srv6_sid_format_usid_lib_explicit_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &no_srv6_sid_format_usid_lib_explicit_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &srv6_sid_format_usid_wlib_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE, &no_srv6_sid_format_usid_wlib_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE,
+			&srv6_sid_format_usid_wide_lib_explicit_cmd);
+	install_element(SRV6_SID_FORMAT_USID_F4816_NODE,
+			&no_srv6_sid_format_usid_wide_lib_explicit_cmd);
 	install_element(SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE,
 			&srv6_sid_format_explicit_cmd);
 	install_element(SRV6_SID_FORMAT_UNCOMPRESSED_F4024_NODE,

From ba376a0b264681fbcc53dfb8bdc708056b599260 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sat, 17 May 2025 08:44:49 +0000
Subject: [PATCH 06/25] zebra: Abstract APIs to manage SRv6 SID blocks

Refactor code to manage SID blocks.

This commit does no functional change. It does a refactoring of the
existing code to manage SID blocks.

There are several places in the code where we need to allocate/release
SID blocks. This commit defines APIs to allocate/release SID blocks,
so we can call these APIs where needed without having to duplicate code.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 82 +++++++++++++++++++++++++++++++---------------
 zebra/zebra_srv6.h |  2 ++
 2 files changed, 57 insertions(+), 27 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 89d8f23baa14..2eca41113405 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -206,16 +206,12 @@ void zebra_srv6_locator_format_set(struct srv6_locator *locator,
 				   struct srv6_sid_format *format)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
-	struct zebra_srv6_sid_block *block_old, *block_new;
-	struct prefix_ipv6 block_pfx_new;
 	struct listnode *node, *nnode;
 	struct zebra_srv6_sid_ctx *ctx;
 
 	if (!locator)
 		return;
 
-	locator->sid_format = format;
-
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: Locator %s format has changed, old=%s new=%s",
 			   __func__, locator->name,
@@ -244,32 +240,13 @@ void zebra_srv6_locator_format_set(struct srv6_locator *locator,
 			   __func__, locator->name);
 
 	/* Release the current parent block */
-	block_old = locator->sid_block;
-	if (block_old) {
-		block_old->refcnt--;
-		if (block_old->refcnt == 0) {
-			listnode_delete(srv6->sid_blocks, block_old);
-			zebra_srv6_sid_block_free(block_old);
-		}
-	}
-	locator->sid_block = NULL;
+	zebra_srv6_sid_locator_block_release(locator);
 
-	block_pfx_new = locator->prefix;
-	if (format)
-		block_pfx_new.prefixlen = format->block_len;
-	else
-		block_pfx_new.prefixlen = locator->block_bits_length;
-	apply_mask(&block_pfx_new);
+	/* Change format */
+	locator->sid_format = format;
 
 	/* Allocate the new parent block */
-	block_new = zebra_srv6_sid_block_lookup(&block_pfx_new);
-	if (!block_new) {
-		block_new = zebra_srv6_sid_block_alloc(format, &block_pfx_new);
-		listnode_add(srv6->sid_blocks, block_new);
-	}
-
-	block_new->refcnt++;
-	locator->sid_block = block_new;
+	zebra_srv6_sid_locator_block_alloc(locator);
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: Locator %s format has changed, send SRV6_LOCATOR_ADD notification to zclients",
@@ -576,6 +553,57 @@ zebra_srv6_sid_block_lookup(struct prefix_ipv6 *prefix)
 	return NULL;
 }
 
+static void zebra_srv6_sid_block_refcnt_increment(struct zebra_srv6_sid_block *block)
+{
+	block->refcnt++;
+}
+
+static void zebra_srv6_sid_block_refcnt_decrement(struct zebra_srv6_sid_block *block)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+
+	assert(block->refcnt > 0);
+
+	block->refcnt--;
+	if (block->refcnt == 0) {
+		listnode_delete(srv6->sid_blocks, block);
+		zebra_srv6_sid_block_free(block);
+	}
+}
+
+void zebra_srv6_sid_locator_block_alloc(struct srv6_locator *locator)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+	struct zebra_srv6_sid_block *block_new;
+	struct prefix_ipv6 block_pfx_new;
+	struct srv6_sid_format *format;
+
+	format = locator->sid_format;
+
+	block_pfx_new = locator->prefix;
+	if (format)
+		block_pfx_new.prefixlen = format->block_len;
+	else
+		block_pfx_new.prefixlen = locator->block_bits_length;
+	apply_mask(&block_pfx_new);
+
+	/* Allocate the new parent block */
+	block_new = zebra_srv6_sid_block_lookup(&block_pfx_new);
+	if (!block_new) {
+		block_new = zebra_srv6_sid_block_alloc(format, &block_pfx_new);
+		listnode_add(srv6->sid_blocks, block_new);
+	}
+
+	zebra_srv6_sid_block_refcnt_increment(block_new);
+	locator->sid_block = block_new;
+}
+
+void zebra_srv6_sid_locator_block_release(struct srv6_locator *locator)
+{
+	zebra_srv6_sid_block_refcnt_decrement(locator->sid_block);
+	locator->sid_block = NULL;
+}
+
 /* --- Zebra SRv6 SID management functions ---------------------------------- */
 
 /**
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index a056dcadaf8e..9f8a67c73be6 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -302,6 +302,8 @@ extern void zebra_srv6_sid_block_free(struct zebra_srv6_sid_block *block);
 extern void delete_zebra_srv6_sid_block(void *val);
 extern struct zebra_srv6_sid_block *
 zebra_srv6_sid_block_lookup(struct prefix_ipv6 *prefix);
+void zebra_srv6_sid_locator_block_alloc(struct srv6_locator *locator);
+void zebra_srv6_sid_locator_block_release(struct srv6_locator *locator);
 
 extern struct zebra_srv6_sid *
 zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx, struct in6_addr *sid_value,

From a31ef7bdae62ce50b9530922ee4c9e3c9cc9fee2 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 06:25:38 +0000
Subject: [PATCH 07/25] zebra: Parse and validate SIDs early

Currently, when SID Manager gets a SID allocation request from a daemon,
it first does some work (e.g. checking if the SID has been already
allocated) and only after it decompose the SID received and verifies
that the SID is valid.

However, there is no point to do any work if the SID is not valid.
Therefore, it makes sense to do the SID validity check early and return
immediately if the SID is not valid.

This commit moves the check for SID validity early in the SID allocation
request handling function.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 2eca41113405..344e7ceb2566 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -1564,6 +1564,13 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 	if (!ctx || !sid_value)
 		return -1;
 
+	/* Get parent locator and function of the provided SID */
+	if (!zebra_srv6_sid_decompose(sid_value, &block, &locator, &sid_func, &sid_func_wide)) {
+		zlog_err("%s: invalid SM request arguments: parent block/locator not found for SID %pI6",
+			 __func__, sid_value);
+		return -1;
+	}
+
 	/* Check if we already have a SID associated with the provided context */
 	for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, s)) {
 		if (memcmp(&s->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0) {
@@ -1600,14 +1607,6 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		}
 	}
 
-	/* Get parent locator and function of the provided SID */
-	if (!zebra_srv6_sid_decompose(sid_value, &block, &locator, &sid_func,
-				      &sid_func_wide)) {
-		zlog_err("%s: invalid SM request arguments: parent block/locator not found for SID %pI6",
-			 __func__, sid_value);
-		return -1;
-	}
-
 	if (ctx->behavior == ZEBRA_SEG6_LOCAL_ACTION_END) {
 		zctx = zebra_srv6_sid_ctx_alloc();
 		zctx->ctx = *ctx;

From 03b9d6d3a833893d190c91d91d7323e68701b5dc Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 07:02:23 +0000
Subject: [PATCH 08/25] zebra: Add function to perform SID ctx lookup

Add a function to perform SID lookup by context.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 13 +++++++++++++
 zebra/zebra_srv6.h |  1 +
 2 files changed, 14 insertions(+)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 344e7ceb2566..baee9d2a3786 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -161,6 +161,19 @@ void delete_zebra_srv6_sid_ctx(void *val)
 	zebra_srv6_sid_ctx_free((struct zebra_srv6_sid_ctx *)val);
 }
 
+struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_lookup(const struct srv6_sid_ctx *ctx)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+	struct zebra_srv6_sid_ctx *zctx;
+	struct listnode *node;
+
+	for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, zctx))
+		if (memcmp(&zctx->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0)
+			return zctx;
+
+	return NULL;
+}
+
 /* --- Zebra SRv6 SID format management functions --------------------------- */
 
 void srv6_sid_format_register(struct srv6_sid_format *format)
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 9f8a67c73be6..908bc826078b 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -334,5 +334,6 @@ extern int srv6_manager_get_sid_response(struct zebra_srv6_sid *sid,
 extern struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_alloc(void);
 extern void zebra_srv6_sid_ctx_free(struct zebra_srv6_sid_ctx *ctx);
 extern void delete_zebra_srv6_sid_ctx(void *val);
+extern struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_lookup(const struct srv6_sid_ctx *ctx);
 
 #endif /* _ZEBRA_SRV6_H */

From 3669d03855a0befa1aef07080acb6c14d53e9672 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 09:09:04 +0000
Subject: [PATCH 09/25] zebra: Refactor release_srv6_sid() function

Refactor release_srv6_sid() function to make it more readable and
maintainable.

There is no functional change.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 41 ++++++++++++++++++++---------------------
 1 file changed, 20 insertions(+), 21 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index baee9d2a3786..8fed45012bff 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -2251,6 +2251,25 @@ static int release_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
 	return 0;
 }
 
+static void release_srv6_sid_func(const struct zebra_srv6_sid_ctx *zctx)
+{
+	if (!(zctx->sid->block->sid_format &&
+	      zctx->sid->block->sid_format->type == SRV6_SID_FORMAT_TYPE_USID &&
+	      zctx->ctx.behavior == ZEBRA_SEG6_LOCAL_ACTION_END) &&
+	    !(!zctx->sid->block->sid_format && zctx->ctx.behavior == ZEBRA_SEG6_LOCAL_ACTION_END)) {
+		if (zctx->sid->alloc_mode == SRV6_SID_ALLOC_MODE_EXPLICIT)
+			/* Release SRv6 SID function */
+			release_srv6_sid_func_explicit(zctx->sid->block, zctx->sid->func,
+						       zctx->sid->wide_func);
+		else if (zctx->sid->alloc_mode == SRV6_SID_ALLOC_MODE_DYNAMIC)
+			/* Release SRv6 SID function */
+			release_srv6_sid_func_dynamic(zctx->sid->block, zctx->sid->func);
+		else
+			/* We should never arrive here */
+			assert(0);
+	}
+}
+
 /**
  * Core function, release the SRv6 SID associated with a given context.
  *
@@ -2309,27 +2328,7 @@ int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
 				   srv6_sid_ctx2str(buf, sizeof(buf),
 						    &zctx->ctx));
 
-		if (!(zctx->sid->block->sid_format &&
-		      zctx->sid->block->sid_format->type ==
-			      SRV6_SID_FORMAT_TYPE_USID &&
-		      zctx->ctx.behavior == ZEBRA_SEG6_LOCAL_ACTION_END) &&
-		    !(!zctx->sid->block->sid_format &&
-		      zctx->ctx.behavior == ZEBRA_SEG6_LOCAL_ACTION_END)) {
-			if (zctx->sid->alloc_mode ==
-			    SRV6_SID_ALLOC_MODE_EXPLICIT)
-				/* Release SRv6 SID function */
-				release_srv6_sid_func_explicit(zctx->sid->block,
-							       zctx->sid->func,
-							       zctx->sid->wide_func);
-			else if (zctx->sid->alloc_mode ==
-				 SRV6_SID_ALLOC_MODE_DYNAMIC)
-				/* Release SRv6 SID function */
-				release_srv6_sid_func_dynamic(zctx->sid->block,
-							      zctx->sid->func);
-			else
-				/* We should never arrive here */
-				assert(0);
-		}
+		release_srv6_sid_func(zctx);
 
 		/* Free the SID */
 		zebra_srv6_sid_free(zctx->sid);

From 1678a69ae3548f7e8f6dd2f4a6fc33da2c9d0243 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 07:22:59 +0000
Subject: [PATCH 10/25] zebra: Refactor get_srv6_sid_explicit() function

Refactor get_srv6_sid_explicit() function to make it more readable
and maintainable.

There is no functional change.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 135 +++++++++++++++++----------------------------
 1 file changed, 52 insertions(+), 83 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 8fed45012bff..c15d2b470810 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -39,8 +39,7 @@ DEFINE_MTYPE_STATIC(SRV6_MGR, ZEBRA_SRV6_SID_CTX, "SRv6 SID context");
 static struct zebra_srv6 g_srv6;
 
 /* Prototypes */
-static int release_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
-					 uint32_t sid_func);
+static void release_srv6_sid_func(const struct zebra_srv6_sid_ctx *zctx);
 
 /* define hooks for the basic API, so that it can be specialized or served
  * externally
@@ -1566,9 +1565,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 				 struct in6_addr *sid_value, bool is_localonly)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
-	struct zebra_srv6_sid_ctx *s = NULL;
 	struct zebra_srv6_sid_ctx *zctx = NULL;
-	struct listnode *node;
 	uint32_t sid_func = 0, sid_func_wide = 0;
 	struct srv6_locator *locator = NULL;
 	struct zebra_srv6_sid_block *block = NULL;
@@ -1585,45 +1582,66 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 	}
 
 	/* Check if we already have a SID associated with the provided context */
-	for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, s)) {
-		if (memcmp(&s->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0) {
-			/*
-			 * If the context is already associated with a SID that has the same SID value, then
-			 * return the existing SID
-			 */
-			if (sid_same(&s->sid->value, sid_value)) {
-				if (IS_ZEBRA_DEBUG_SRV6)
-					zlog_debug("%s: returning existing SRv6 SID %pI6 ctx %s",
-						   __func__, &s->sid->value,
-						   srv6_sid_ctx2str(buf,
-								    sizeof(buf),
-								    ctx));
-				*sid = s->sid;
-				return 0;
-			}
+	zctx = zebra_srv6_sid_ctx_lookup(ctx);
 
-			/*
-			 * It is not allowed to allocate an explicit SID for a given context if the context
-			 * is already associated with an explicit SID
-			 */
-			if (s->sid->alloc_mode == SRV6_SID_ALLOC_MODE_EXPLICIT) {
-				zlog_err("%s: cannot alloc SID %pI6 for ctx %s: ctx already associated with SID %pI6",
-					 __func__, sid_value,
-					 srv6_sid_ctx2str(buf, sizeof(buf),
-							  &s->ctx),
-					 &s->sid->value);
+	if (zctx) {
+		/*
+		 * If the context is already associated with a SID that has the same SID value, then
+		 * return the existing SID
+		 */
+		if (sid_same(&zctx->sid->value, sid_value)) {
+			if (IS_ZEBRA_DEBUG_SRV6)
+				zlog_debug("%s: returning existing SRv6 SID %pI6 ctx %s", __func__,
+					   &zctx->sid->value,
+					   srv6_sid_ctx2str(buf, sizeof(buf), ctx));
+			*sid = zctx->sid;
+			return 0;
+		}
+
+		/* Allocate an explicit SID function for the SID */
+		if (ctx->behavior != ZEBRA_SEG6_LOCAL_ACTION_END)
+			if (!alloc_srv6_sid_func_explicit(block, sid_func, sid_func_wide)) {
+				zlog_err("%s: invalid SM request arguments: failed to allocate SID function %u from block %pFX",
+					 __func__, sid_func, &block->prefix);
 				return -1;
 			}
 
-			zctx = s;
-			break;
+		/*
+		 * If we already have a SID associated with this context, we need to
+		 * deallocate the current SID function before allocating the new one
+		 */
+		if (zctx->sid) {
+			if (IS_ZEBRA_DEBUG_SRV6)
+				zlog_debug("%s: ctx %s already associated with SID %pI6, releasing existing SID",
+					   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx),
+					   &zctx->sid->value);
+
+			release_srv6_sid_func(zctx);
+
+			zctx->sid->value = *sid_value;
+			zctx->sid->locator = locator;
+			zctx->sid->block = block;
+			zctx->sid->func = sid_func;
+			zctx->sid->wide_func = sid_func_wide;
+			zctx->sid->alloc_mode = SRV6_SID_ALLOC_MODE_EXPLICIT;
+
+			*sid = zctx->sid;
+			(*sid)->ctx = zctx;
 		}
-	}
+	} else {
+		/* Allocate an explicit SID function for the SID */
+		if (ctx->behavior != ZEBRA_SEG6_LOCAL_ACTION_END)
+			if (!alloc_srv6_sid_func_explicit(block, sid_func, sid_func_wide)) {
+				zlog_err("%s: invalid SM request arguments: failed to allocate SID function %u from block %pFX",
+					 __func__, sid_func, &block->prefix);
+				return -1;
+			}
 
-	if (ctx->behavior == ZEBRA_SEG6_LOCAL_ACTION_END) {
+		/* If we don't have a zebra SID context for this context, allocate a new one */
 		zctx = zebra_srv6_sid_ctx_alloc();
 		zctx->ctx = *ctx;
 
+		/* Allocate the SID to store SID information */
 		*sid = zebra_srv6_sid_alloc(zctx, sid_value, locator, block, sid_func,
 					    SRV6_SID_ALLOC_MODE_EXPLICIT);
 		if (!(*sid)) {
@@ -1635,56 +1653,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		(*sid)->ctx = zctx;
 		zctx->sid = *sid;
 		listnode_add(srv6->sids, zctx);
-
-		if (IS_ZEBRA_DEBUG_SRV6)
-			zlog_debug("%s: allocated explicit SRv6 SID %pI6 for context %s", __func__,
-				   &(*sid)->value, srv6_sid_ctx2str(buf, sizeof(buf), ctx));
-
-		return 1;
-	}
-
-	/* Allocate an explicit SID function for the SID */
-	if (!alloc_srv6_sid_func_explicit(block, sid_func, sid_func_wide)) {
-		zlog_err("%s: invalid SM request arguments: failed to allocate SID function %u from block %pFX",
-			 __func__, sid_func, &block->prefix);
-		return -1;
-	}
-
-	if (!zctx) {
-		/* If we don't have a zebra SID context for this context, allocate a new one */
-		zctx = zebra_srv6_sid_ctx_alloc();
-		zctx->ctx = *ctx;
-	} else {
-		/*
-		 * If we already have a SID associated with this context, we need to
-		 * deallocate the current SID function before allocating the new one
-		 */
-		if (zctx->sid) {
-			if (IS_ZEBRA_DEBUG_SRV6)
-				zlog_debug("%s: ctx %s already associated with a dynamic SID %pI6, releasing dynamic SID",
-					   __func__,
-					   srv6_sid_ctx2str(buf, sizeof(buf),
-							    ctx),
-					   &zctx->sid->value);
-
-			release_srv6_sid_func_dynamic(block, zctx->sid->func);
-			zebra_srv6_sid_free(zctx->sid);
-			zctx->sid = NULL;
-		}
-	}
-
-	/* Allocate the SID to store SID information */
-	*sid = zebra_srv6_sid_alloc(zctx, sid_value, locator, block, sid_func,
-				    SRV6_SID_ALLOC_MODE_EXPLICIT);
-	if (!(*sid)) {
-		flog_err(EC_ZEBRA_SM_CANNOT_ASSIGN_SID,
-			 "%s: failed to create SRv6 SID %s (%pI6)", __func__,
-			 srv6_sid_ctx2str(buf, sizeof(buf), ctx), sid_value);
-		return -1;
 	}
-	(*sid)->ctx = zctx;
-	zctx->sid = *sid;
-	listnode_add(srv6->sids, zctx);
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: allocated explicit SRv6 SID %pI6 for context %s",

From 5d0f5756c9edd1d942bdb19cf7e45c607b2defe4 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 07:56:48 +0000
Subject: [PATCH 11/25] zebra: Refactor get_srv6_sid_dynamic() function

Refactor get_srv6_sid_dynamic() function to make it more readable and
maintainable.

There is no functional change.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 23 ++++-------------------
 1 file changed, 4 insertions(+), 19 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index c15d2b470810..b27357508ae3 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -1683,9 +1683,7 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_block *block;
 	struct srv6_sid_format *format;
-	struct zebra_srv6_sid_ctx *s = NULL;
 	struct zebra_srv6_sid_ctx *zctx;
-	struct listnode *node;
 	struct in6_addr sid_value;
 	uint32_t sid_func = 0;
 	char buf[256];
@@ -1700,23 +1698,10 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	 * If we already have a SID for the provided context, we return the existing
 	 * SID instead of allocating a new one.
 	 */
-	for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, s)) {
-		if (locator && s->sid && s->sid->locator) {
-			if (strncmp(s->sid->locator->name, locator->name,
-				    SRV6_LOCNAME_SIZE)) {
-				continue;
-			}
-		}
-		if (memcmp(&s->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0) {
-			if (IS_ZEBRA_DEBUG_SRV6)
-				zlog_debug("%s: returning existing SID %s %pI6",
-					   __func__,
-					   srv6_sid_ctx2str(buf, sizeof(buf),
-							    ctx),
-					   &s->sid->value);
-			*sid = s->sid;
-			return 0;
-		}
+	zctx = zebra_srv6_sid_ctx_lookup(ctx);
+	if (zctx && strncmp(zctx->sid->locator->name, locator->name, SRV6_LOCNAME_SIZE)) {
+		*sid = zctx->sid;
+		return 0;
 	}
 
 	if (format && format->type == SRV6_SID_FORMAT_TYPE_USID &&

From 356f28f528bbb03c691bc431b1286899d80afb4a Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 00:14:09 +0000
Subject: [PATCH 12/25] zebra: Add data structure to store SIDs parent locators

With the introduction of support for multiple locators, daemons can
now request a SID context from multiple locators. We need to have a
mechanism to track which locators a SID context has been allocated from.

To support this, we extend the SID context data structure by adding a
list 'entries' that tracks the locators from which the SID context has
been allocated.

When a daemon requests a SID context from a locator, we create a new
SID entry in the entries list of the SID context.

When a daemon releases a SID context from a locator, we remove the
corresponding entry from the entries list. If there are no other entries,
we release the SID context because it is no longer used.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 182 +++++++++++++++++++++++++++++++++++++++++++++
 zebra/zebra_srv6.h |  45 +++++++++++
 2 files changed, 227 insertions(+)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index b27357508ae3..dd269b18e718 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -35,6 +35,7 @@ DEFINE_MTYPE_STATIC(SRV6_MGR, ZEBRA_SRV6_USID_WLIB,
 		    "SRv6 uSID Wide LIB information");
 DEFINE_MTYPE_STATIC(SRV6_MGR, ZEBRA_SRV6_SID, "SRv6 SID");
 DEFINE_MTYPE_STATIC(SRV6_MGR, ZEBRA_SRV6_SID_CTX, "SRv6 SID context");
+DEFINE_MTYPE_STATIC(SRV6_MGR, ZEBRA_SRV6_SID_ENTRY_INFO, "SRv6 SID entry information");
 
 static struct zebra_srv6 g_srv6;
 
@@ -205,6 +206,36 @@ struct srv6_sid_format *srv6_sid_format_lookup(const char *name)
 	return NULL;
 }
 
+static void zebra_srv6_sid_entry_del_by_locator(struct zebra_srv6_sid *sid,
+						struct srv6_locator *locator)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+	struct zebra_srv6_sid_entry *entry;
+
+	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry)
+		if (entry->locator == locator) {
+			zebra_srv6_sid_entry_list_del(&sid->entries, entry);
+			zebra_srv6_sid_entry_free(entry);
+		}
+
+	if (zebra_srv6_sid_entry_list_count(&sid->entries) == 0) {
+		listnode_delete(srv6->sids, sid->ctx);
+		zebra_srv6_sid_ctx_free(sid->ctx);
+
+		zebra_srv6_sid_free(sid);
+	}
+}
+
+void zebra_srv6_sid_entry_del_by_locator_all_sids(struct srv6_locator *locator)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+	struct listnode *node, *nnode;
+	struct zebra_srv6_sid_ctx *ctx;
+
+	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx))
+		zebra_srv6_sid_entry_del_by_locator(ctx->sid, locator);
+}
+
 /*
  * Called to change the SID format of a locator.
  *
@@ -648,12 +679,20 @@ zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx, struct in6_addr *sid_value,
 	sid->func = sid_func;
 	sid->alloc_mode = alloc_mode;
 	sid->client_list = list_new();
+	zebra_srv6_sid_entry_list_init(&sid->entries);
 
 	return sid;
 }
 
 void zebra_srv6_sid_free(struct zebra_srv6_sid *sid)
 {
+	struct zebra_srv6_sid_entry *entry;
+
+	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry) {
+		zebra_srv6_sid_entry_list_del(&sid->entries, entry);
+		zebra_srv6_sid_entry_free(entry);
+	}
+	zebra_srv6_sid_entry_list_fini(&sid->entries);
 	list_delete(&sid->client_list);
 	XFREE(MTYPE_ZEBRA_SRV6_SID, sid);
 }
@@ -668,6 +707,136 @@ void delete_zebra_srv6_sid(void *val)
 	zebra_srv6_sid_free((struct zebra_srv6_sid *)val);
 }
 
+void zebra_srv6_sid_client_add(struct zebra_srv6_sid *sid, bool is_localonly,
+			       struct srv6_locator *locator, struct zserv *client)
+{
+	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_client *zclient;
+
+	entry = zebra_srv6_sid_entry_lookup(sid, locator->name, is_localonly);
+	if (!entry)
+		return;
+
+	zclient = zebra_srv6_sid_client_lookup(sid, entry, client);
+	if (!zclient) {
+		zclient = XCALLOC(MTYPE_ZEBRA_SRV6_SID_ENTRY_INFO,
+				  sizeof(struct zebra_srv6_sid_client));
+		zclient->client = client;
+
+		zebra_srv6_sid_client_list_add_tail(&entry->clients_list, zclient);
+	}
+}
+
+struct zebra_srv6_sid_entry *zebra_srv6_sid_entry_alloc(void)
+{
+	struct zebra_srv6_sid_entry *entry = NULL;
+
+	entry = XCALLOC(MTYPE_ZEBRA_SRV6_SID_ENTRY_INFO, sizeof(struct zebra_srv6_sid_entry));
+
+	return entry;
+}
+
+void zebra_srv6_sid_entry_free(struct zebra_srv6_sid_entry *entry)
+{
+	struct zebra_srv6_sid_client *sclient;
+
+	frr_each_safe (zebra_srv6_sid_client_list, &entry->clients_list, sclient) {
+		zebra_srv6_sid_client_list_del(&entry->clients_list, sclient);
+		XFREE(MTYPE_ZEBRA_SRV6_SID_ENTRY_INFO, sclient);
+	}
+	zebra_srv6_sid_client_list_fini(&entry->clients_list);
+	XFREE(MTYPE_ZEBRA_SRV6_SID_ENTRY_INFO, entry);
+}
+
+struct zebra_srv6_sid_entry *zebra_srv6_sid_entry_lookup(struct zebra_srv6_sid *sid,
+							 const char *locator_name,
+							 bool is_localonly)
+{
+	struct zebra_srv6_sid_entry *entry;
+
+	if (!locator_name)
+		return NULL;
+
+	frr_each (zebra_srv6_sid_entry_list, &sid->entries, entry)
+		if (!strncmp(entry->locator->name, locator_name, SRV6_LOCNAME_SIZE) &&
+		    entry->is_localonly == is_localonly)
+			return entry;
+
+	return NULL;
+}
+
+void zebra_srv6_sid_client_del(struct zebra_srv6_sid *sid, struct zebra_srv6_sid_entry *entry,
+			       struct zebra_srv6_sid_client *sclient)
+{
+	zebra_srv6_sid_client_list_del(&entry->clients_list, sclient);
+	XFREE(MTYPE_ZEBRA_SRV6_SID_ENTRY_INFO, sclient);
+	if (zebra_srv6_sid_client_list_count(&entry->clients_list) == 0) {
+		zebra_srv6_sid_entry_list_del(&sid->entries, entry);
+		zebra_srv6_sid_entry_free(entry);
+	}
+}
+
+void zebra_srv6_sid_client_del_all(struct zebra_srv6_sid *sid, struct zserv *client)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_client *zclient;
+
+	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry) {
+		zclient = zebra_srv6_sid_client_lookup(sid, entry, client);
+		if (!zclient)
+			continue;
+
+		/* Remove the client from the list of clients using the SID */
+		zebra_srv6_sid_client_list_del(&entry->clients_list, zclient);
+		XFREE(MTYPE_ZEBRA_SRV6_SID_ENTRY_INFO, zclient);
+		if (zebra_srv6_sid_client_list_count(&entry->clients_list) == 0) {
+			zebra_srv6_sid_entry_list_del(&sid->entries, entry);
+			zebra_srv6_sid_entry_free(entry);
+		}
+	}
+
+	/*
+	 * If the SID is not used by any other client, then deallocate it
+	 * and remove it from the SRv6 database.
+	 */
+	if (zebra_srv6_sid_entry_list_count(&sid->entries) == 0) {
+		release_srv6_sid_func(sid->ctx);
+
+		/* Remove the SID context from the list and free memory */
+		listnode_delete(srv6->sids, sid->ctx);
+		zebra_srv6_sid_ctx_free(sid->ctx);
+
+		/* Free the SID */
+		zebra_srv6_sid_free(sid);
+	}
+}
+
+struct zebra_srv6_sid_entry *zebra_srv6_sid_entry_add(struct zebra_srv6_sid *sid,
+						      const char *locator_name,
+						      struct in6_addr *sid_value, bool is_localonly)
+{
+	struct zebra_srv6_sid_entry *entry;
+	struct srv6_locator *locator;
+
+	locator = zebra_srv6_locator_lookup(locator_name);
+	if (!locator)
+		return NULL;
+
+	entry = zebra_srv6_sid_entry_lookup(sid, locator_name, is_localonly);
+	if (entry)
+		return entry;
+
+	entry = zebra_srv6_sid_entry_alloc();
+	entry->locator = locator;
+	entry->sid_value = *sid_value;
+	entry->is_localonly = is_localonly;
+	zebra_srv6_sid_client_list_init(&entry->clients_list);
+	zebra_srv6_sid_entry_list_add_tail(&sid->entries, entry);
+
+	return entry;
+}
+
 void zebra_srv6_locator_add(struct srv6_locator *locator)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
@@ -2224,6 +2393,19 @@ static void release_srv6_sid_func(const struct zebra_srv6_sid_ctx *zctx)
 	}
 }
 
+struct zebra_srv6_sid_client *zebra_srv6_sid_client_lookup(struct zebra_srv6_sid *sid,
+							   struct zebra_srv6_sid_entry *entry,
+							   struct zserv *client)
+{
+	struct zebra_srv6_sid_client *zclient;
+
+	frr_each (zebra_srv6_sid_client_list, &entry->clients_list, zclient)
+		if (zclient->client == client)
+			return zclient;
+
+	return NULL;
+}
+
 /**
  * Core function, release the SRv6 SID associated with a given context.
  *
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 908bc826078b..cb63c3738cc8 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -152,6 +152,27 @@ srv6_sid_alloc_mode2str(enum srv6_sid_alloc_mode alloc_mode)
 	}
 }
 
+PREDECL_DLIST(zebra_srv6_sid_client_list);
+
+struct zebra_srv6_sid_client {
+	struct zserv *client;
+
+	struct zebra_srv6_sid_client_list_item item;
+};
+
+DECLARE_DLIST(zebra_srv6_sid_client_list, struct zebra_srv6_sid_client, item);
+
+PREDECL_DLIST(zebra_srv6_sid_entry_list);
+
+struct zebra_srv6_sid_entry {
+	struct zebra_srv6_sid_client_list_head clients_list;
+	struct srv6_locator *locator;
+	struct in6_addr sid_value;
+	bool is_localonly;
+
+	struct zebra_srv6_sid_entry_list_item item;
+};
+
 /* SRv6 SID instance. */
 struct zebra_srv6_sid {
 	/*
@@ -184,8 +205,13 @@ struct zebra_srv6_sid {
 
 	/* List of clients that are using the SID */
 	struct list *client_list;
+
+	/* List of SID entries allocated for this SID */
+	struct zebra_srv6_sid_entry_list_head entries;
 };
 
+DECLARE_DLIST(zebra_srv6_sid_entry_list, struct zebra_srv6_sid_entry, item);
+
 /*
  * Zebra SRv6 SID context.
  * A context defines a behavior and (optionally) some behavior-specific
@@ -313,6 +339,25 @@ zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx, struct in6_addr *sid_value,
 extern void zebra_srv6_sid_free(struct zebra_srv6_sid *sid);
 extern void delete_zebra_srv6_sid(void *val);
 
+struct zebra_srv6_sid_entry *zebra_srv6_sid_entry_alloc(void);
+void zebra_srv6_sid_entry_free(struct zebra_srv6_sid_entry *client);
+struct zebra_srv6_sid_client *zebra_srv6_sid_client_lookup(struct zebra_srv6_sid *sid,
+							   struct zebra_srv6_sid_entry *entry,
+							   struct zserv *client);
+struct zebra_srv6_sid_entry *zebra_srv6_sid_entry_lookup(struct zebra_srv6_sid *sid,
+							 const char *locator_name,
+							 bool is_localonly);
+void zebra_srv6_sid_client_del_all(struct zebra_srv6_sid *sid, struct zserv *client);
+void zebra_srv6_sid_client_del(struct zebra_srv6_sid *sid, struct zebra_srv6_sid_entry *entry,
+			       struct zebra_srv6_sid_client *sclient);
+void zebra_srv6_sid_entry_del_by_locator_all_sids(struct srv6_locator *locator);
+void zebra_srv6_sid_client_add(struct zebra_srv6_sid *sid, bool is_localonly,
+			       struct srv6_locator *locator, struct zserv *client);
+struct zebra_srv6_sid_entry *zebra_srv6_sid_entry_add(struct zebra_srv6_sid *sid,
+						      const char *locator_name,
+						      struct in6_addr *sid_value,
+						      bool is_localonly);
+
 extern void srv6_manager_get_sid_call(struct zebra_srv6_sid **sid, struct zserv *client,
 				      struct srv6_sid_ctx *ctx, struct in6_addr *sid_value,
 				      const char *locator_name, bool is_localonly);

From 5bf3c69da68ac59c6f9b3c7348cd5b17c142eb12 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 00:41:32 +0000
Subject: [PATCH 13/25] zebra: Fix compose and decompose functions

This commit does the following changes:
* extend the sid_compose() function to support allocation of local-only
SIDs
* extend the sid_compose() function to support SIDs allocated from wide
LIB
* fix an issue in the sid_compose() function.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 62 ++++++++++++++++++++++++++++------------------
 1 file changed, 38 insertions(+), 24 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index dd269b18e718..8a595ed4fdff 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -1186,29 +1186,33 @@ void zebra_srv6_encap_src_addr_unset(void)
  * @param sid_value SRv6 SID address returned
  * @param locator Parent locator of the SRv6 SID
  * @param sid_func Function part of the SID
+ * @param sid_func_wide Wide function of the SID
  * @param is_localonly SID is local-only
  * @return True if success, False otherwise
  */
-static bool zebra_srv6_sid_compose(struct in6_addr *sid_value,
-				   struct srv6_locator *locator,
-				   uint32_t sid_func)
+static bool zebra_srv6_sid_compose(struct in6_addr *sid_value, struct srv6_locator *locator,
+				   uint32_t sid_func, uint32_t sid_func_wide, bool is_localonly)
 {
 	uint8_t offset, func_len;
 	struct srv6_sid_format *format;
+	struct zebra_srv6_sid_block *block;
 
 	if (!sid_value || !locator)
 		return false;
 
+	block = locator->sid_block;
+
 	format = locator->sid_format;
 	if (format) {
-		offset = format->block_len + format->node_len;
+		offset = is_localonly ? format->block_len : format->block_len + format->node_len;
 		func_len = format->function_len;
 	} else {
-		offset = locator->block_bits_length + locator->node_bits_length;
+		offset = is_localonly ? locator->block_bits_length
+				      : locator->block_bits_length + locator->node_bits_length;
 		func_len = locator->function_bits_length;
 	}
 
-	*sid_value = locator->prefix.prefix;
+	*sid_value = is_localonly ? block->prefix.prefix : locator->prefix.prefix;
 	for (uint8_t idx = 0; idx < func_len; idx++) {
 		uint8_t tidx = offset + idx;
 
@@ -1216,6 +1220,13 @@ static bool zebra_srv6_sid_compose(struct in6_addr *sid_value,
 		if (sid_func >> (func_len - 1 - idx) & 0x1)
 			sid_value->s6_addr[tidx / 8] |= 0x1 << (7 - tidx % 8);
 	}
+	for (uint8_t idx = 0; idx < func_len; idx++) {
+		uint8_t tidx = offset + func_len + idx;
+
+		sid_value->s6_addr[tidx / 8] &= ~(0x1 << (7 - tidx % 8));
+		if (sid_func_wide >> (func_len - 1 - idx) & 0x1)
+			sid_value->s6_addr[tidx / 8] |= 0x1 << (7 - tidx % 8);
+	}
 
 	return true;
 }
@@ -1338,29 +1349,31 @@ static bool zebra_srv6_sid_decompose(struct in6_addr *sid_value,
 				 (struct prefix *)&tmp_prefix)) {
 			format = b->sid_format;
 
-			if (!format)
-				continue;
-
-			offset = format->block_len + format->node_len;
-			func_len = format->function_len;
+			if (format) {
+				offset = format->block_len;
+				func_len = format->function_len;
+			} else {
+				offset = b->prefix.prefixlen;
+				func_len = SRV6_SID_FORMAT_USID_F3216_FUNCTION_LEN;
+			}
 
 			for (uint8_t idx = 0; idx < func_len; idx++) {
 				uint8_t tidx = offset + idx;
 				*sid_func |= (sid_value->s6_addr[tidx / 8] &
 					      (0x1 << (7 - tidx % 8)))
-					     << ((func_len - 1 - idx) / 8);
+					     << (((func_len - 1 - idx) / 8) * 8);
 			}
 
 			/*
 			 * If function comes from the Wide LIB range, we also
 			 * need to get the Wide function.
 			 */
-			if (*sid_func >= format->config.usid.wlib_start &&
+			if (format && format->type == SRV6_SID_FORMAT_TYPE_USID &&
+			    *sid_func >= format->config.usid.wlib_start &&
 			    *sid_func <= format->config.usid.wlib_end) {
 				format = b->sid_format;
 
-				offset = format->block_len + format->node_len +
-					 format->function_len;
+				offset = format->block_len + format->function_len;
 
 				for (uint8_t idx = 0; idx < 16; idx++) {
 					uint8_t tidx = offset + idx;
@@ -1413,6 +1426,7 @@ static bool alloc_srv6_sid_func_explicit(struct zebra_srv6_sid_block *block,
 		if (format->type == SRV6_SID_FORMAT_TYPE_USID) {
 			uint32_t elib_start = format->config.usid.elib_start;
 			uint32_t elib_end = format->config.usid.elib_end;
+			uint32_t wlib_start = format->config.usid.wlib_start;
 			uint32_t wlib_end = format->config.usid.wlib_end;
 			uint32_t ewlib_start = format->config.usid.ewlib_start;
 			uint32_t ewlib_end = wlib_end;
@@ -1450,10 +1464,9 @@ static bool alloc_srv6_sid_func_explicit(struct zebra_srv6_sid_block *block,
 
 				/* Ensure that the requested SID function has not already been taken */
 				for (ALL_LIST_ELEMENTS_RO(block->u.usid
-								  .wide_lib[sid_func]
+								  .wide_lib[sid_func - wlib_start]
 								  .func_allocated,
-							  node,
-							  sid_wide_func_ptr))
+							  node, sid_wide_func_ptr))
 					if (*sid_wide_func_ptr == sid_wide_func)
 						break;
 
@@ -1469,11 +1482,10 @@ static bool alloc_srv6_sid_func_explicit(struct zebra_srv6_sid_block *block,
 				 */
 				sid_wide_func_ptr = zebra_srv6_sid_func_alloc(
 					sid_wide_func);
-				listnode_add(block->u.usid.wide_lib[sid_func]
+				listnode_add(block->u.usid.wide_lib[sid_func - wlib_start]
 						     .func_allocated,
 					     sid_wide_func_ptr);
-				block->u.usid.wide_lib[sid_func]
-					.num_func_allocated++;
+				block->u.usid.wide_lib[sid_func - wlib_start].num_func_allocated++;
 			} else {
 				zlog_warn("%s: function %u is outside ELIB [%u/%u] and EWLIB alloc ranges [%u/%u]",
 					  __func__, sid_func, elib_start,
@@ -1819,6 +1831,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 				 srv6_sid_ctx2str(buf, sizeof(buf), ctx), sid_value);
 			return -1;
 		}
+		(*sid)->wide_func = sid_func_wide;
 		(*sid)->ctx = zctx;
 		zctx->sid = *sid;
 		listnode_add(srv6->sids, zctx);
@@ -1889,7 +1902,7 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 		}
 
 		/* Compose the SID as the locator followed by the SID function */
-		zebra_srv6_sid_compose(&sid_value, locator, sid_func);
+		zebra_srv6_sid_compose(&sid_value, locator, sid_func, 0, is_localonly);
 	}
 
 	/* Allocate a zebra SID context to store SID context information */
@@ -2065,6 +2078,7 @@ static bool release_srv6_sid_func_explicit(struct zebra_srv6_sid_block *block,
 		if (format->type == SRV6_SID_FORMAT_TYPE_USID) {
 			uint32_t elib_start = format->config.usid.elib_start;
 			uint32_t elib_end = format->config.usid.elib_end;
+			uint32_t wlib_start = format->config.usid.wlib_start;
 			uint32_t ewlib_start = format->config.usid.ewlib_start;
 			uint32_t ewlib_end = format->config.usid.wlib_end;
 			uint32_t *sid_wide_func_ptr = NULL;
@@ -2097,7 +2111,7 @@ static bool release_srv6_sid_func_explicit(struct zebra_srv6_sid_block *block,
 
 				/* Lookup SID function in the functions allocated list of EWLIB range */
 				for (ALL_LIST_ELEMENTS_RO(block->u.usid
-								  .wide_lib[sid_func]
+								  .wide_lib[sid_func - wlib_start]
 								  .func_allocated,
 							  node, sid_wide_func_ptr))
 					if (*sid_wide_func_ptr == sid_wide_func)
@@ -2111,7 +2125,7 @@ static bool release_srv6_sid_func_explicit(struct zebra_srv6_sid_block *block,
 				}
 
 				/* Release the SID function from the EWLIB range */
-				listnode_delete(block->u.usid.wide_lib[sid_func]
+				listnode_delete(block->u.usid.wide_lib[sid_func - wlib_start]
 							.func_allocated,
 						sid_wide_func_ptr);
 				zebra_srv6_sid_func_free(sid_wide_func_ptr);

From 3e8d401ed92903903b516ae3e9a854e7c0218902 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 09:30:34 +0000
Subject: [PATCH 14/25] zebra: Extend get/release SID APIs to support multiple
 locators

Currently, the get SID and release SID APIs can allocate a SID from a
single locator.

This commit extends the APIs to support multiple locators

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 132 ++++++++++++++++++++++-----------------------
 1 file changed, 63 insertions(+), 69 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 8a595ed4fdff..a741cbae137e 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -19,6 +19,7 @@
 #include "zebra/zebra_errors.h"
 #include "zebra/ge_netlink.h"
 #include "zebra/interface.h"
+#include "typesafe.h"
 
 #include <stdio.h>
 #include <string.h>
@@ -248,10 +249,6 @@ void zebra_srv6_sid_entry_del_by_locator_all_sids(struct srv6_locator *locator)
 void zebra_srv6_locator_format_set(struct srv6_locator *locator,
 				   struct srv6_sid_format *format)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
-	struct listnode *node, *nnode;
-	struct zebra_srv6_sid_ctx *ctx;
-
 	if (!locator)
 		return;
 
@@ -267,16 +264,7 @@ void zebra_srv6_locator_format_set(struct srv6_locator *locator,
 	/* Notify zclients that the locator is no longer valid */
 	zebra_notify_srv6_locator_delete(locator);
 
-	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx)) {
-		if (!ctx->sid || ctx->sid->locator != locator)
-			continue;
-
-		if (ctx->sid)
-			zebra_srv6_sid_free(ctx->sid);
-
-		listnode_delete(srv6->sids, ctx);
-		zebra_srv6_sid_ctx_free(ctx);
-	}
+	zebra_srv6_sid_entry_del_by_locator_all_sids(locator);
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: Locator %s format has changed, send SRV6_LOCATOR_DEL notification to zclients",
@@ -312,8 +300,7 @@ void zebra_srv6_sid_format_changed_cb(struct srv6_sid_format *format)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct srv6_locator *locator;
-	struct listnode *node, *nnode;
-	struct zebra_srv6_sid_ctx *ctx;
+	struct listnode *node;
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: SID format %s has changed. Notifying zclients.",
@@ -329,16 +316,7 @@ void zebra_srv6_sid_format_changed_cb(struct srv6_sid_format *format)
 			/* Notify zclients that the locator is no longer valid */
 			zebra_notify_srv6_locator_delete(locator);
 
-			for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx)) {
-				if (!ctx->sid || ctx->sid->locator != locator)
-					continue;
-
-				if (ctx->sid)
-					zebra_srv6_sid_free(ctx->sid);
-
-				listnode_delete(srv6->sids, ctx);
-				zebra_srv6_sid_ctx_free(ctx);
-			}
+			zebra_srv6_sid_entry_del_by_locator_all_sids(locator);
 
 			/* Notify zclients about the updated locator */
 			zebra_notify_srv6_locator_add(locator);
@@ -1770,12 +1748,12 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		 * If the context is already associated with a SID that has the same SID value, then
 		 * return the existing SID
 		 */
-		if (sid_same(&zctx->sid->value, sid_value)) {
+		if (zctx->sid->func == sid_func && zctx->sid->wide_func == sid_func_wide) {
 			if (IS_ZEBRA_DEBUG_SRV6)
 				zlog_debug("%s: returning existing SRv6 SID %pI6 ctx %s", __func__,
-					   &zctx->sid->value,
-					   srv6_sid_ctx2str(buf, sizeof(buf), ctx));
+					   sid_value, srv6_sid_ctx2str(buf, sizeof(buf), ctx));
 			*sid = zctx->sid;
+			zebra_srv6_sid_entry_add(*sid, locator->name, sid_value, is_localonly);
 			return 0;
 		}
 
@@ -1793,9 +1771,9 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		 */
 		if (zctx->sid) {
 			if (IS_ZEBRA_DEBUG_SRV6)
-				zlog_debug("%s: ctx %s already associated with SID %pI6, releasing existing SID",
+				zlog_debug("%s: ctx %s already associated with SID %u, releasing SID",
 					   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx),
-					   &zctx->sid->value);
+					   zctx->sid->func);
 
 			release_srv6_sid_func(zctx);
 
@@ -1837,10 +1815,11 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		listnode_add(srv6->sids, zctx);
 	}
 
+	zebra_srv6_sid_entry_add(*sid, locator->name, sid_value, is_localonly);
+
 	if (IS_ZEBRA_DEBUG_SRV6)
-		zlog_debug("%s: allocated explicit SRv6 SID %pI6 for context %s",
-			   __func__, &(*sid)->value,
-			   srv6_sid_ctx2str(buf, sizeof(buf), ctx));
+		zlog_debug("%s: allocated explicit SRv6 SID function %u for context %s", __func__,
+			   (*sid)->func, srv6_sid_ctx2str(buf, sizeof(buf), ctx));
 
 	return 1;
 }
@@ -1881,7 +1860,17 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	 * SID instead of allocating a new one.
 	 */
 	zctx = zebra_srv6_sid_ctx_lookup(ctx);
-	if (zctx && strncmp(zctx->sid->locator->name, locator->name, SRV6_LOCNAME_SIZE)) {
+	if (zctx) {
+		if (((format && format->type == SRV6_SID_FORMAT_TYPE_USID) ||
+		     (!format && CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID))) &&
+		    ctx->behavior == ZEBRA_SEG6_LOCAL_ACTION_END) {
+			sid_value = locator->prefix.prefix;
+		} else {
+			zebra_srv6_sid_compose(&sid_value, locator, zctx->sid->func,
+					       zctx->sid->wide_func, is_localonly);
+		}
+		zebra_srv6_sid_entry_add(zctx->sid, locator->name, &sid_value, is_localonly);
+
 		*sid = zctx->sid;
 		return 0;
 	}
@@ -1922,10 +1911,11 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	zctx->sid = *sid;
 	listnode_add(srv6->sids, zctx);
 
+	zebra_srv6_sid_entry_add(*sid, locator->name, &sid_value, is_localonly);
+
 	if (IS_ZEBRA_DEBUG_SRV6)
-		zlog_debug("%s: allocated new dynamic SRv6 SID %pI6 for context %s",
-			   __func__, &(*sid)->value,
-			   srv6_sid_ctx2str(buf, sizeof(buf), ctx));
+		zlog_debug("%s: allocated new dynamic SRv6 SID %u for context %s", __func__,
+			   (*sid)->func, srv6_sid_ctx2str(buf, sizeof(buf), ctx));
 
 	return 1;
 }
@@ -2434,49 +2424,50 @@ int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	char buf[256];
+	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_client *zclient;
 
 	if (!zctx || !zctx->sid)
 		return -1;
 
 	if (IS_ZEBRA_DEBUG_SRV6)
-		zlog_debug("%s: releasing SRv6 SID %pI6 associated with ctx %s (proto=%u, instance=%u)",
-			   __func__, &zctx->sid->value,
-			   srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx),
-			   client->proto, client->instance);
-
-	if (zctx->sid->locator != locator) {
-		zlog_err("SRv6 SID %pI6 ctx %s is not allocated from the provided locator %s",
-			 &zctx->sid->value, srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx),
+		zlog_debug("%s: releasing SRv6 SID func %u associated with ctx %s (proto=%u, instance=%u)",
+			   __func__, zctx->sid->func,
+			   srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx), client->proto,
+			   client->instance);
+
+	entry = zebra_srv6_sid_entry_lookup(zctx->sid, locator->name, is_localonly);
+	if (!entry) {
+		zlog_err("SRv6 SID func %u ctx %s is not allocated from the provided locator %s",
+			 zctx->sid->func, srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx),
 			 locator->name);
 		return -1;
 	}
 
-	/* Ensures the SID is in use by the client */
-	if (!listnode_lookup(zctx->sid->client_list, client)) {
-		flog_err(EC_ZEBRA_SM_DAEMON_MISMATCH, "%s: Daemon mismatch!!",
-			 __func__);
+	zclient = zebra_srv6_sid_client_lookup(zctx->sid, entry, client);
+	if (!zclient) {
+		flog_err(EC_ZEBRA_SM_DAEMON_MISMATCH, "%s: Daemon mismatch!!", __func__);
 		return -1;
 	}
 
 	/* Remove the client from the list of clients using the SID */
-	listnode_delete(zctx->sid->client_list, client);
+	zebra_srv6_sid_client_del(zctx->sid, entry, zclient);
 
 	if (IS_ZEBRA_DEBUG_SRV6)
-		zlog_debug("%s: released SRv6 SID %pI6 associated with ctx %s (proto=%u, instance=%u)",
-			   __func__, &zctx->sid->value,
-			   srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx),
-			   client->proto, client->instance);
+		zlog_debug("%s: released SRv6 SID %u associated with ctx %s (proto=%u, instance=%u)",
+			   __func__, zctx->sid->func,
+			   srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx), client->proto,
+			   client->instance);
 
 	/*
 	 * If the SID is not used by any other client, then deallocate it
 	 * and remove it from the SRv6 database.
 	 */
-	if (listcount(zctx->sid->client_list) == 0) {
+	if (zebra_srv6_sid_entry_list_count(&zctx->sid->entries) == 0) {
 		if (IS_ZEBRA_DEBUG_SRV6)
-			zlog_debug("%s: SRv6 SID %pI6 associated with ctx %s is no longer in use, removing it from SRv6 database",
-				   __func__, &zctx->sid->value,
-				   srv6_sid_ctx2str(buf, sizeof(buf),
-						    &zctx->ctx));
+			zlog_debug("%s: SRv6 SID %u associated with ctx %s is no longer in use, removing it from SRv6 database",
+				   __func__, zctx->sid->func,
+				   srv6_sid_ctx2str(buf, sizeof(buf), &zctx->ctx));
 
 		release_srv6_sid_func(zctx);
 
@@ -2545,12 +2536,22 @@ static int srv6_manager_get_sid_internal(struct zebra_srv6_sid **sid, struct zse
 	struct listnode *node;
 	struct zserv *c;
 	char buf[256];
+	struct srv6_locator *locator = NULL;
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: getting SRv6 SID for ctx %s, sid_value=%pI6, locator_name=%s",
 			   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx),
 			   sid_value ? sid_value : &in6addr_any, locator_name);
 
+	if (locator_name && locator_name[0] != '\0') {
+		locator = zebra_srv6_locator_lookup(locator_name);
+		if (!locator) {
+			zlog_err("%s: invalid SM request arguments: SRv6 locator '%s' does not exist",
+				 __func__, locator_name);
+			return -1;
+		}
+	}
+
 	ret = get_srv6_sid(sid, ctx, sid_value, locator_name, is_localonly);
 	if (ret < 0) {
 		zlog_warn("%s: not got SRv6 SID for ctx %s, sid_value=%pI6, locator_name=%s",
@@ -2612,7 +2613,6 @@ int release_daemon_srv6_sids(struct zserv *client)
 	struct listnode *node, *nnode;
 	struct zebra_srv6_sid_ctx *ctx;
 	int count = 0;
-	int ret;
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: releasing SRv6 SIDs for client proto %s, instance %d, session %u",
@@ -2620,14 +2620,8 @@ int release_daemon_srv6_sids(struct zserv *client)
 			   client->instance, client->session_id);
 
 	/* Iterate over the SIDs and release SIDs used by the client daemon */
-	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx)) {
-		if (!listnode_lookup(ctx->sid->client_list, client))
-			continue;
-
-		ret = release_srv6_sid(client, ctx, ctx->sid->locator, false);
-		if (ret == 0)
-			count++;
-	}
+	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx))
+		zebra_srv6_sid_client_del_all(ctx->sid, client);
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: released %d SRv6 SIDs", __func__, count);

From 70c8db344b7992f3349d5c07e57d23acc867082c Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sun, 18 May 2025 20:13:29 +0000
Subject: [PATCH 15/25] zebra: Extend vty to show SIDs from multiple locators

Extend show SRv6 SIDs CLI to display SIDs allocated from all the
different locators.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6_vty.c | 278 ++++++++++++++++++++++++-----------------
 1 file changed, 161 insertions(+), 117 deletions(-)

diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index c457f91fada2..207ceb90c99d 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -342,64 +342,71 @@ static const char *show_srv6_sid_seg6_context(char *str, size_t size, const stru
 
 static void do_show_srv6_sid_line(struct ttable *tt, struct zebra_srv6_sid *sid)
 {
-	struct listnode *node;
 	struct zserv *client;
 	char clients[256];
 	char ctx[256] = {};
 	char behavior[256] = {};
 	char alloc_mode_str[10] = {};
 	char locator_name[SRV6_LOCNAME_SIZE];
+	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_client *sclient;
 	int ret;
 
-	/* Zclients */
-	if (listcount(sid->client_list)) {
-		bool first = true;
-		int i = 0;
-		for (ALL_LIST_ELEMENTS_RO(sid->client_list, node, client)) {
-			if (first) {
-				ret = snprintf(clients + i, sizeof(clients) - i, "%s(%d)",
-					       zebra_route_string(client->proto), client->instance);
-				first = false;
-			} else {
-				ret = snprintf(clients + i, sizeof(clients) - i, ", %s(%d)",
-					       zebra_route_string(client->proto), client->instance);
-			}
+	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry) {
+		/* Zclients */
+		if (zebra_srv6_sid_client_list_count(&entry->clients_list)) {
+			bool first = true;
+			int i = 0;
+			frr_each_safe (zebra_srv6_sid_client_list, &entry->clients_list, sclient) {
+				client = sclient->client;
+				if (first) {
+					ret = snprintf(clients + i, sizeof(clients) - i, "%s(%d)",
+						       zebra_route_string(client->proto),
+						       client->instance);
+					first = false;
+				} else {
+					ret = snprintf(clients + i, sizeof(clients) - i, ", %s(%d)",
+						       zebra_route_string(client->proto),
+						       client->instance);
+				}
 
-			if (ret > 0)
-				i += ret;
+				if (ret > 0)
+					i += ret;
+			}
 		}
-	}
 
-	/* Behavior */
-	if (sid->locator) {
-		if ((sid->locator->sid_format &&
-		     sid->locator->sid_format->type == SRV6_SID_FORMAT_TYPE_USID) ||
-		    (!sid->locator->sid_format &&
-		     CHECK_FLAG(sid->locator->flags, SRV6_LOCATOR_USID))) {
-			snprintf(behavior, sizeof(behavior), "%s",
-				 show_srv6_sid_seg6_action(sid->ctx->ctx.behavior));
-		} else {
-			snprintf(behavior, sizeof(behavior), "%s",
-				 seg6local_action2str(sid->ctx->ctx.behavior));
+		/* Behavior */
+		if (entry->locator) {
+			if ((entry->locator->sid_format &&
+			     entry->locator->sid_format->type == SRV6_SID_FORMAT_TYPE_USID) ||
+			    (!entry->locator->sid_format &&
+			     CHECK_FLAG(entry->locator->flags, SRV6_LOCATOR_USID))) {
+				snprintf(behavior, sizeof(behavior), "%s",
+					 show_srv6_sid_seg6_action(sid->ctx->ctx.behavior));
+			} else {
+				snprintf(behavior, sizeof(behavior), "%s",
+					 seg6local_action2str(sid->ctx->ctx.behavior));
+			}
 		}
-	}
 
-	/* SID context */
-	show_srv6_sid_seg6_context(ctx, sizeof(ctx), &sid->ctx->ctx, sid->ctx->ctx.behavior);
+		/* SID context */
+		show_srv6_sid_seg6_context(ctx, sizeof(ctx), &sid->ctx->ctx,
+					   sid->ctx->ctx.behavior);
 
-	if (strlen(ctx) == 0)
-		snprintf(ctx, sizeof(ctx), "-");
+		if (strlen(ctx) == 0)
+			snprintf(ctx, sizeof(ctx), "-");
 
-	if (sid->locator)
-		snprintf(locator_name, sizeof(locator_name), "%s", sid->locator->name);
-	else
-		snprintf(locator_name, sizeof(locator_name), "-");
+		if (entry->locator)
+			snprintf(locator_name, sizeof(locator_name), "%s", entry->locator->name);
+		else
+			snprintf(locator_name, sizeof(locator_name), "-");
 
-	snprintf(alloc_mode_str, sizeof(alloc_mode_str), "%s",
-		 srv6_sid_alloc_mode2str(sid->alloc_mode));
+		snprintf(alloc_mode_str, sizeof(alloc_mode_str), "%s",
+			 srv6_sid_alloc_mode2str(sid->alloc_mode));
 
-	ttable_add_row(tt, "%pI6|%s|%s|%s|%s|%s", &sid->value, behavior, ctx, clients, locator_name,
-		       alloc_mode_str);
+		ttable_add_row(tt, "%pI6|%s|%s|%s|%s|%s", &entry->sid_value, behavior, ctx,
+			       clients, locator_name, alloc_mode_str);
+	}
 }
 
 static void do_show_srv6_sid_json(struct vty *vty, json_object **json, struct srv6_locator *locator,
@@ -412,75 +419,81 @@ static void do_show_srv6_sid_json(struct vty *vty, json_object **json, struct sr
 	struct vrf *vrf;
 	struct zebra_vrf *zvrf;
 	struct interface *ifp;
-	struct listnode *node;
 	struct zserv *client;
+	struct zebra_srv6_sid_client *sclient;
+	struct zebra_srv6_sid_entry *entry;
 	char buf[256];
 
 	if (!sid_ctx || !sid_ctx->sid)
 		return;
 
-	if (locator && sid_ctx->sid->locator != locator)
-		return;
+	frr_each (zebra_srv6_sid_entry_list, &sid_ctx->sid->entries, entry) {
+		if (locator && entry->locator != locator)
+			return;
 
-	json_sid = json_object_new_object();
-	json_sid_ctx = json_object_new_object();
+		json_sid = json_object_new_object();
+		json_sid_ctx = json_object_new_object();
 
-	json_object_string_addf(json_sid, "sid", "%pI6", &sid_ctx->sid->value);
-	if ((sid_ctx->sid->locator->sid_format &&
-	     sid_ctx->sid->locator->sid_format->type == SRV6_SID_FORMAT_TYPE_USID) ||
-	    (!sid_ctx->sid->locator->sid_format &&
-	     CHECK_FLAG(sid_ctx->sid->locator->flags, SRV6_LOCATOR_USID))) {
-		json_object_string_add(json_sid, "behavior",
-				       show_srv6_sid_seg6_action(sid_ctx->ctx.behavior));
-	} else {
-		json_object_string_add(json_sid, "behavior",
-				       seg6local_action2str(sid_ctx->ctx.behavior));
-	}
+		json_object_string_addf(json_sid, "sid", "%pI6", &entry->sid_value);
+		if ((entry->locator->sid_format &&
+		     entry->locator->sid_format->type == SRV6_SID_FORMAT_TYPE_USID) ||
+		    (!entry->locator->sid_format &&
+		     CHECK_FLAG(entry->locator->flags, SRV6_LOCATOR_USID))) {
+			json_object_string_add(json_sid, "behavior",
+					       show_srv6_sid_seg6_action(sid_ctx->ctx.behavior));
+		} else {
+			json_object_string_add(json_sid, "behavior",
+					       seg6local_action2str(sid_ctx->ctx.behavior));
+		}
 
-	if (sid_ctx->ctx.vrf_id) {
-		json_object_int_add(json_sid_ctx, "vrfId", sid_ctx->ctx.vrf_id);
+		if (sid_ctx->ctx.vrf_id) {
+			json_object_int_add(json_sid_ctx, "vrfId", sid_ctx->ctx.vrf_id);
 
-		vrf = vrf_lookup_by_id(sid_ctx->ctx.vrf_id);
-		if (vrf)
-			json_object_string_add(json_sid_ctx, "vrfName", vrf->name);
+			vrf = vrf_lookup_by_id(sid_ctx->ctx.vrf_id);
+			if (vrf)
+				json_object_string_add(json_sid_ctx, "vrfName", vrf->name);
 
-		zvrf = vrf_info_lookup(sid_ctx->ctx.vrf_id);
-		if (vrf)
-			json_object_int_add(json_sid_ctx, "table", zvrf->table_id);
-	}
-	if (sid_ctx->ctx.ifindex) {
-		json_object_int_add(json_sid_ctx, "interfaceIndex", sid_ctx->ctx.ifindex);
-		RB_FOREACH (vrf, vrf_id_head, &vrfs_by_id) {
-			ifp = if_lookup_by_index(sid_ctx->ctx.ifindex, vrf->vrf_id);
-			if (ifp)
-				json_object_string_add(json_sid_ctx, "interfaceName", ifp->name);
+			zvrf = vrf_info_lookup(sid_ctx->ctx.vrf_id);
+			if (vrf)
+				json_object_int_add(json_sid_ctx, "table", zvrf->table_id);
 		}
-	}
-	if (memcmp(&sid_ctx->ctx.nh6, &in6addr_any, sizeof(struct in6_addr)) != 0) {
-		json_object_string_addf(json_sid_ctx, "nexthopIpv6Address", "%pI6",
-					&sid_ctx->ctx.nh6);
-	}
-	json_object_object_add(json_sid, "context", json_sid_ctx);
-
-	json_object_string_add(json_sid, "locator", sid_ctx->sid->locator->name);
-	json_object_string_add(json_sid, "allocationMode",
-			       srv6_sid_alloc_mode2str(sid_ctx->sid->alloc_mode));
-
-	/* Zclients */
-	json_sid_clients = json_object_new_array();
-	if (listcount(sid_ctx->sid->client_list)) {
-		for (ALL_LIST_ELEMENTS_RO(sid_ctx->sid->client_list, node, client)) {
-			json_sid_client = json_object_new_object();
-			json_object_string_add(json_sid_client, "protocol",
-					       zebra_route_string(client->proto));
-			json_object_int_add(json_sid_client, "instance", client->instance);
-			json_object_array_add(json_sid_clients, json_sid_client);
+		if (sid_ctx->ctx.ifindex) {
+			json_object_int_add(json_sid_ctx, "interfaceIndex", sid_ctx->ctx.ifindex);
+			RB_FOREACH (vrf, vrf_id_head, &vrfs_by_id) {
+				ifp = if_lookup_by_index(sid_ctx->ctx.ifindex, vrf->vrf_id);
+				if (ifp)
+					json_object_string_add(json_sid_ctx, "interfaceName",
+							       ifp->name);
+			}
 		}
-	}
-	json_object_object_add(json_sid, "clients", json_sid_clients);
+		if (memcmp(&sid_ctx->ctx.nh6, &in6addr_any, sizeof(struct in6_addr)) != 0) {
+			json_object_string_addf(json_sid_ctx, "nexthopIpv6Address", "%pI6",
+						&sid_ctx->ctx.nh6);
+		}
+		json_object_object_add(json_sid, "context", json_sid_ctx);
+
+		json_object_string_add(json_sid, "locator", entry->locator->name);
+		json_object_string_add(json_sid, "allocationMode",
+				       srv6_sid_alloc_mode2str(sid_ctx->sid->alloc_mode));
+
+		/* Zclients */
+		json_sid_clients = json_object_new_array();
+		if (zebra_srv6_sid_client_list_count(&entry->clients_list)) {
+			frr_each_safe (zebra_srv6_sid_client_list, &entry->clients_list, sclient) {
+				client = sclient->client;
+				json_sid_client = json_object_new_object();
+				json_object_string_add(json_sid_client, "protocol",
+						       zebra_route_string(client->proto));
+				json_object_int_add(json_sid_client, "instance", client->instance);
+				json_object_array_add(json_sid_clients, json_sid_client);
+			}
+		}
+		json_object_object_add(json_sid, "clients", json_sid_clients);
 
-	json_object_object_add(*json, inet_ntop(AF_INET6, &sid_ctx->sid->value, buf, sizeof(buf)),
-			       json_sid);
+		json_object_object_add(*json,
+				       inet_ntop(AF_INET6, &entry->sid_value, buf, sizeof(buf)),
+				       json_sid);
+	}
 }
 
 static void do_show_srv6_sid_specific(struct vty *vty, json_object **json,
@@ -488,6 +501,8 @@ static void do_show_srv6_sid_specific(struct vty *vty, json_object **json,
 				      struct zebra_srv6_sid_ctx *sid_ctx)
 {
 	struct ttable *tt;
+	struct zebra_srv6_sid_entry *entry;
+	bool found = false;
 
 	if (json) {
 		do_show_srv6_sid_json(vty, json, locator, sid_ctx);
@@ -506,9 +521,15 @@ static void do_show_srv6_sid_specific(struct vty *vty, json_object **json,
 			return;
 		}
 
-		if (locator && sid_ctx->sid->locator != locator) {
-			ttable_del(tt);
-			return;
+		if (locator) {
+			frr_each_safe (zebra_srv6_sid_entry_list, &sid_ctx->sid->entries, entry) {
+				if (entry->locator == locator) {
+					found = true;
+					break;
+				}
+			}
+			if (!found)
+				return;
 		}
 
 		do_show_srv6_sid_line(tt, sid_ctx->sid);
@@ -540,6 +561,7 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 	struct zebra_srv6_sid_ctx *ctx;
 	struct listnode *node;
 	struct ttable *tt;
+	char *table;
 
 	if (json) {
 		for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, ctx)) {
@@ -548,7 +570,9 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 				continue;
 
 			/* Skip SIDs from locators we are not interested in */
-			if (locator && ctx->sid->locator != locator)
+			if (locator &&
+			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
+			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
 				continue;
 
 			do_show_srv6_sid_json(vty, json, locator, ctx);
@@ -568,7 +592,9 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 				continue;
 
 			/* Skip SIDs from locators we are not interested in */
-			if (locator && ctx->sid->locator != locator)
+			if (locator &&
+			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
+			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
 				continue;
 
 			do_show_srv6_sid_line(tt, ctx->sid);
@@ -584,13 +610,9 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 		ttable_colseps(tt, 5, LEFT, true, ' ');
 
 		/* Dump the generated table. */
-		if (tt->nrows > 1) {
-			char *table;
-
-			table = ttable_dump(tt, "\n");
-			vty_out(vty, "%s\n", table);
-			XFREE(MTYPE_TMP_TTABLE, table);
-		}
+		table = ttable_dump(tt, "\n");
+		vty_out(vty, "%s\n", table);
+		XFREE(MTYPE_TMP_TTABLE, table);
 		ttable_del(tt);
 	}
 }
@@ -613,6 +635,8 @@ DEFPY (show_srv6_sid,
 	struct zebra_srv6_sid_ctx *sid_ctx = NULL, *c;
 	struct listnode *node;
 	json_object *json = NULL;
+	bool found = false;
+	struct zebra_srv6_sid_entry *entry;
 
 	if (uj)
 		json = json_object_new_object();
@@ -630,9 +654,14 @@ DEFPY (show_srv6_sid,
 
 	if (!IPV6_ADDR_SAME(&sid_value, &in6addr_any)) {
 		for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, c)) {
-			if (c->sid && IPV6_ADDR_SAME(&c->sid->value, &sid_value)) {
-				sid_ctx = c;
-				break;
+			if (!c->sid)
+				continue;
+
+			frr_each_safe (zebra_srv6_sid_entry_list, &c->sid->entries, entry) {
+				if (IPV6_ADDR_SAME(&entry->sid_value, &sid_value)) {
+					sid_ctx = c;
+					break;
+				}
 			}
 		}
 
@@ -645,14 +674,21 @@ DEFPY (show_srv6_sid,
 		}
 	}
 
-	if (locator && sid_ctx)
-		if (!sid_ctx->sid || sid_ctx->sid->locator != locator) {
+	if (locator && sid_ctx) {
+		frr_each_safe (zebra_srv6_sid_entry_list, &sid_ctx->sid->entries, entry) {
+			if (entry->locator == locator) {
+				found = true;
+				break;
+			}
+		}
+		if (!sid_ctx->sid || !found) {
 			if (uj)
 				vty_json(vty, json); /* Return empty json */
 			else
 				vty_out(vty, "%% Can't find the SRv6 SID in the provided locator\n");
 			return CMD_WARNING;
 		}
+	}
 
 	if (sid_ctx)
 		do_show_srv6_sid_specific(vty, uj ? &json : NULL, locator, sid_ctx);
@@ -763,6 +799,7 @@ DEFUN (no_srv6_locator,
 	struct listnode *node, *nnode;
 	struct zebra_srv6_sid_ctx *ctx;
 	struct srv6_locator *locator = zebra_srv6_locator_lookup(argv[2]->arg);
+	struct zebra_srv6_sid_entry *entry;
 
 	if (!locator) {
 		vty_out(vty, "%% Can't find SRv6 locator\n");
@@ -770,14 +807,21 @@ DEFUN (no_srv6_locator,
 	}
 
 	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx)) {
-		if (!ctx->sid || ctx->sid->locator != locator)
+		if (!ctx->sid)
 			continue;
 
-		if (ctx->sid)
+		frr_each_safe (zebra_srv6_sid_entry_list, &ctx->sid->entries, entry)
+			if (entry->locator == locator) {
+				zebra_srv6_sid_entry_list_del(&ctx->sid->entries, entry);
+				zebra_srv6_sid_entry_free(entry);
+			}
+
+		if (zebra_srv6_sid_entry_list_count(&ctx->sid->entries) == 0) {
 			zebra_srv6_sid_free(ctx->sid);
 
-		listnode_delete(srv6->sids, ctx);
-		zebra_srv6_sid_ctx_free(ctx);
+			listnode_delete(srv6->sids, ctx);
+			zebra_srv6_sid_ctx_free(ctx);
+		}
 	}
 
 	block = locator->sid_block;

From fe0410b829e48363fe2e36470d5d2ebeabb157c2 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 16 May 2025 11:58:15 +0000
Subject: [PATCH 16/25] zebra: Notify daemons when SIDs are allocated

Extend SID Manager to notify daemons when a SID they are interested in
is allocated/released.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 106 ++++++++++++++++++++++++++++++++-------------
 1 file changed, 76 insertions(+), 30 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index a741cbae137e..a4beca158292 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -43,6 +43,9 @@ static struct zebra_srv6 g_srv6;
 /* Prototypes */
 static void release_srv6_sid_func(const struct zebra_srv6_sid_ctx *zctx);
 
+static bool zebra_srv6_sid_compose(struct in6_addr *sid_value, struct srv6_locator *locator,
+				   uint32_t sid_func, uint32_t sid_func_wide, bool is_localonly);
+
 /* define hooks for the basic API, so that it can be specialized or served
  * externally
  */
@@ -685,6 +688,54 @@ void delete_zebra_srv6_sid(void *val)
 	zebra_srv6_sid_free((struct zebra_srv6_sid *)val);
 }
 
+static void zebra_srv6_sid_clients_notify_single(struct zebra_srv6_sid *sid,
+						 struct srv6_locator *locator,
+						 struct zserv *client, bool is_localonly,
+						 enum zapi_srv6_sid_notify notify)
+{
+	struct zebra_srv6_sid_entry *entry;
+	struct in6_addr sid_value = {};
+
+	entry = zebra_srv6_sid_entry_lookup(sid, locator->name, is_localonly);
+	if (!entry)
+		return;
+
+	zebra_srv6_sid_compose(&sid_value, locator, sid->func, sid->wide_func, is_localonly);
+	zsend_srv6_sid_notify(client, &sid->ctx->ctx, &sid_value, sid->func, sid->wide_func,
+			      locator->name, notify);
+}
+
+static void zebra_srv6_sid_clients_release_notify_all(struct zebra_srv6_sid *sid)
+{
+	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_client *zclient;
+
+	frr_each (zebra_srv6_sid_entry_list, &sid->entries, entry)
+		frr_each (zebra_srv6_sid_client_list, &entry->clients_list, zclient)
+			zsend_srv6_sid_notify(zclient->client, &sid->ctx->ctx, &entry->sid_value,
+					      sid->func, sid->wide_func, entry->locator->name,
+					      ZAPI_SRV6_SID_RELEASED);
+}
+
+static void zebra_srv6_sid_clients_notify_all(struct zebra_srv6_sid *sid,
+					      struct srv6_locator *locator, bool is_localonly,
+					      enum zapi_srv6_sid_notify notify)
+{
+	struct in6_addr sid_value = {};
+	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_client *zclient;
+
+	entry = zebra_srv6_sid_entry_lookup(sid, locator->name, is_localonly);
+	if (!entry)
+		return;
+
+	zebra_srv6_sid_compose(&sid_value, locator, sid->func, sid->wide_func, is_localonly);
+
+	frr_each (zebra_srv6_sid_client_list, &entry->clients_list, zclient)
+		zsend_srv6_sid_notify(zclient->client, &sid->ctx->ctx, &sid_value, sid->func,
+				      sid->wide_func, locator->name, notify);
+}
+
 void zebra_srv6_sid_client_add(struct zebra_srv6_sid *sid, bool is_localonly,
 			       struct srv6_locator *locator, struct zserv *client)
 {
@@ -790,6 +841,14 @@ void zebra_srv6_sid_client_del_all(struct zebra_srv6_sid *sid, struct zserv *cli
 	}
 }
 
+static void zebra_srv6_sid_entry_delete_all(struct zebra_srv6_sid *sid)
+{
+	struct zebra_srv6_sid_entry *entry;
+
+	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry)
+		zebra_srv6_sid_entry_list_del(&sid->entries, entry);
+}
+
 struct zebra_srv6_sid_entry *zebra_srv6_sid_entry_add(struct zebra_srv6_sid *sid,
 						      const char *locator_name,
 						      struct in6_addr *sid_value, bool is_localonly)
@@ -1777,6 +1836,9 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 
 			release_srv6_sid_func(zctx);
 
+			zebra_srv6_sid_clients_release_notify_all(zctx->sid);
+			zebra_srv6_sid_entry_delete_all(zctx->sid);
+
 			zctx->sid->value = *sid_value;
 			zctx->sid->locator = locator;
 			zctx->sid->block = block;
@@ -2533,8 +2595,6 @@ static int srv6_manager_get_sid_internal(struct zebra_srv6_sid **sid, struct zse
 					 const char *locator_name, bool is_localonly)
 {
 	int ret = -1;
-	struct listnode *node;
-	struct zserv *c;
 	char buf[256];
 	struct srv6_locator *locator = NULL;
 
@@ -2559,41 +2619,27 @@ static int srv6_manager_get_sid_internal(struct zebra_srv6_sid **sid, struct zse
 			  sid_value ? sid_value : &in6addr_any, locator_name);
 
 		/* Notify client about SID alloc failure */
-		zsend_srv6_sid_notify(client, ctx, sid_value, 0, 0, NULL,
-				      ZAPI_SRV6_SID_FAIL_ALLOC);
+		zebra_srv6_sid_clients_notify_single(*sid, NULL, client, is_localonly,
+						     ZAPI_SRV6_SID_FAIL_ALLOC);
 	} else if (ret == 0) {
 		assert(*sid);
 		if (IS_ZEBRA_DEBUG_SRV6)
 			zlog_debug("%s: got existing SRv6 SID for ctx %s: sid_value=%pI6 (func=%u) (proto=%u, instance=%u, sessionId=%u), notify client",
-				   __func__,
-				   srv6_sid_ctx2str(buf, sizeof(buf), ctx),
-				   &(*sid)->value, (*sid)->func, client->proto,
-				   client->instance, client->session_id);
-		if (!listnode_lookup((*sid)->client_list, client))
-			listnode_add((*sid)->client_list, client);
-
-		zsend_srv6_sid_notify(client, ctx, &(*sid)->value, (*sid)->func,
-				      (*sid)->wide_func,
-				      (*sid)->locator ? (*sid)->locator->name
-						      : NULL,
-				      ZAPI_SRV6_SID_ALLOCATED);
+				   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx), sid_value,
+				   (*sid)->func, client->proto, client->instance,
+				   client->session_id);
+		zebra_srv6_sid_client_add(*sid, is_localonly, locator, client);
+		zebra_srv6_sid_clients_notify_single(*sid, locator, client, is_localonly,
+						     ZAPI_SRV6_SID_ALLOCATED);
 	} else {
 		if (IS_ZEBRA_DEBUG_SRV6)
 			zlog_debug("%s: got new SRv6 SID for ctx %s: sid_value=%pI6 (func=%u) (proto=%u, instance=%u, sessionId=%u), notifying all clients",
-				   __func__,
-				   srv6_sid_ctx2str(buf, sizeof(buf), ctx),
-				   &(*sid)->value, (*sid)->func, client->proto,
-				   client->instance, client->session_id);
-		if (!listnode_lookup((*sid)->client_list, client))
-			listnode_add((*sid)->client_list, client);
-
-		for (ALL_LIST_ELEMENTS_RO((*sid)->client_list, node, c))
-			zsend_srv6_sid_notify(c, ctx, &(*sid)->value,
-					      (*sid)->func, (*sid)->wide_func,
-					      (*sid)->locator
-						      ? (*sid)->locator->name
-						      : NULL,
-					      ZAPI_SRV6_SID_ALLOCATED);
+				   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx), sid_value,
+				   (*sid)->func, client->proto, client->instance,
+				   client->session_id);
+		zebra_srv6_sid_client_add(*sid, is_localonly, locator, client);
+		zebra_srv6_sid_clients_notify_all(*sid, locator, is_localonly,
+						  ZAPI_SRV6_SID_ALLOCATED);
 	}
 
 	return ret;

From f669f4e68bcf21867d92ca3f85790bb5b1e2990f Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sat, 17 May 2025 06:32:38 +0000
Subject: [PATCH 17/25] zebra: Remove unused code in SRv6 SID Manager

This commit removes some code in SRv6 SID Manager that is no longer
used.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 23 +++++++----------------
 zebra/zebra_srv6.h | 19 +++++--------------
 2 files changed, 12 insertions(+), 30 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index a4beca158292..073b96c29c47 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -634,32 +634,27 @@ void zebra_srv6_sid_locator_block_release(struct srv6_locator *locator)
  * Alloc and fill an SRv6 SID.
  *
  * @param ctx Context associated with the SID to be created
- * @param sid_value IPv6 address associated with the SID to be created
  * @param locator Parent locator of the SID to be created
  * @param sid_block Block from which the SID value has been allocated
  * @param sid_func Function part of the SID to be created
  * @param alloc_mode Allocation mode of the Function (dynamic vs explicit)
  * @return The requested SID
  */
-struct zebra_srv6_sid *
-zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx, struct in6_addr *sid_value,
-		     struct srv6_locator *locator,
-		     struct zebra_srv6_sid_block *sid_block, uint32_t sid_func,
-		     enum srv6_sid_alloc_mode alloc_mode)
+struct zebra_srv6_sid *zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx,
+					    struct srv6_locator *locator,
+					    struct zebra_srv6_sid_block *sid_block,
+					    uint32_t sid_func, enum srv6_sid_alloc_mode alloc_mode)
 {
 	struct zebra_srv6_sid *sid;
 
-	if (!ctx || !sid_value)
+	if (!ctx)
 		return NULL;
 
 	sid = XCALLOC(MTYPE_ZEBRA_SRV6_SID, sizeof(struct zebra_srv6_sid));
 	sid->ctx = ctx;
-	sid->value = *sid_value;
-	sid->locator = locator;
 	sid->block = sid_block;
 	sid->func = sid_func;
 	sid->alloc_mode = alloc_mode;
-	sid->client_list = list_new();
 	zebra_srv6_sid_entry_list_init(&sid->entries);
 
 	return sid;
@@ -674,7 +669,6 @@ void zebra_srv6_sid_free(struct zebra_srv6_sid *sid)
 		zebra_srv6_sid_entry_free(entry);
 	}
 	zebra_srv6_sid_entry_list_fini(&sid->entries);
-	list_delete(&sid->client_list);
 	XFREE(MTYPE_ZEBRA_SRV6_SID, sid);
 }
 
@@ -1839,8 +1833,6 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 			zebra_srv6_sid_clients_release_notify_all(zctx->sid);
 			zebra_srv6_sid_entry_delete_all(zctx->sid);
 
-			zctx->sid->value = *sid_value;
-			zctx->sid->locator = locator;
 			zctx->sid->block = block;
 			zctx->sid->func = sid_func;
 			zctx->sid->wide_func = sid_func_wide;
@@ -1863,7 +1855,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		zctx->ctx = *ctx;
 
 		/* Allocate the SID to store SID information */
-		*sid = zebra_srv6_sid_alloc(zctx, sid_value, locator, block, sid_func,
+		*sid = zebra_srv6_sid_alloc(zctx, locator, block, sid_func,
 					    SRV6_SID_ALLOC_MODE_EXPLICIT);
 		if (!(*sid)) {
 			flog_err(EC_ZEBRA_SM_CANNOT_ASSIGN_SID,
@@ -1961,8 +1953,7 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	zctx->ctx = *ctx;
 
 	/* Allocate the SID to store SID information */
-	*sid = zebra_srv6_sid_alloc(zctx, &sid_value, locator, block, sid_func,
-				    SRV6_SID_ALLOC_MODE_DYNAMIC);
+	*sid = zebra_srv6_sid_alloc(zctx, locator, block, sid_func, SRV6_SID_ALLOC_MODE_DYNAMIC);
 	if (!(*sid)) {
 		flog_err(EC_ZEBRA_SM_CANNOT_ASSIGN_SID,
 			 "%s: failed to create SRv6 SID ctx %s (%pI6)", __func__,
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index cb63c3738cc8..15819c471fd6 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -181,12 +181,6 @@ struct zebra_srv6_sid {
 	 */
 	struct zebra_srv6_sid_ctx *ctx;
 
-	/* SID value (e.g. fc00:0:1:e000::) */
-	struct in6_addr value;
-
-	/* Pointer to the SRv6 locator from which the SID has been allocated */
-	struct srv6_locator *locator;
-
 	/* Pointer to the SRv6 block from which the SID has been allocated */
 	struct zebra_srv6_sid_block *block;
 
@@ -203,9 +197,6 @@ struct zebra_srv6_sid {
 	/* SID allocation mode: dynamic or explicit */
 	enum srv6_sid_alloc_mode alloc_mode;
 
-	/* List of clients that are using the SID */
-	struct list *client_list;
-
 	/* List of SID entries allocated for this SID */
 	struct zebra_srv6_sid_entry_list_head entries;
 };
@@ -331,11 +322,11 @@ zebra_srv6_sid_block_lookup(struct prefix_ipv6 *prefix);
 void zebra_srv6_sid_locator_block_alloc(struct srv6_locator *locator);
 void zebra_srv6_sid_locator_block_release(struct srv6_locator *locator);
 
-extern struct zebra_srv6_sid *
-zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx, struct in6_addr *sid_value,
-		     struct srv6_locator *locator,
-		     struct zebra_srv6_sid_block *sid_block, uint32_t sid_func,
-		     enum srv6_sid_alloc_mode alloc_mode);
+extern struct zebra_srv6_sid *zebra_srv6_sid_alloc(struct zebra_srv6_sid_ctx *ctx,
+						   struct srv6_locator *locator,
+						   struct zebra_srv6_sid_block *sid_block,
+						   uint32_t sid_func,
+						   enum srv6_sid_alloc_mode alloc_mode);
 extern void zebra_srv6_sid_free(struct zebra_srv6_sid *sid);
 extern void delete_zebra_srv6_sid(void *val);
 

From 81f1b5b723aa1c93e7b63ad456abb6eb8dfa4f5a Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Wed, 14 May 2025 20:19:13 +0000
Subject: [PATCH 18/25] zebra: Move SRv6 SIDs data structure under the block

Currently, SID Manager stores all SRv6 SIDs that have been allocated in
a single srv6_sids data structure.

This approach exhibits scalability issues when we allocate many SIDs
from many different blocks, because all SIDs are stored in a single
list and the SID lookup requires scanning the entire list in the worst
case.

In order to improve performance, it's better to move the srv6_sids list
under the block. So each block keeps only a subset of SIDs, i.e. SIDs
allocated under it. This means that we have smaller srv6_sids list,
which can improve performance.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c     | 129 ++++++++++++++++++++++++++---------------
 zebra/zebra_srv6.h     |   9 +--
 zebra/zebra_srv6_vty.c |  94 ++++++++++++++++++------------
 3 files changed, 145 insertions(+), 87 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 073b96c29c47..6e3389c3ced5 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -165,13 +165,13 @@ void delete_zebra_srv6_sid_ctx(void *val)
 	zebra_srv6_sid_ctx_free((struct zebra_srv6_sid_ctx *)val);
 }
 
-struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_lookup(const struct srv6_sid_ctx *ctx)
+struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_lookup(const struct srv6_sid_ctx *ctx,
+						     struct zebra_srv6_sid_block *block)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_ctx *zctx;
 	struct listnode *node;
 
-	for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, zctx))
+	for (ALL_LIST_ELEMENTS_RO(block->sids, node, zctx))
 		if (memcmp(&zctx->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0)
 			return zctx;
 
@@ -213,8 +213,13 @@ struct srv6_sid_format *srv6_sid_format_lookup(const char *name)
 static void zebra_srv6_sid_entry_del_by_locator(struct zebra_srv6_sid *sid,
 						struct srv6_locator *locator)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_block *block;
+
+	if (!locator->sid_block)
+		return;
+
+	block = locator->sid_block;
 
 	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry)
 		if (entry->locator == locator) {
@@ -223,7 +228,7 @@ static void zebra_srv6_sid_entry_del_by_locator(struct zebra_srv6_sid *sid,
 		}
 
 	if (zebra_srv6_sid_entry_list_count(&sid->entries) == 0) {
-		listnode_delete(srv6->sids, sid->ctx);
+		listnode_delete(block->sids, sid->ctx);
 		zebra_srv6_sid_ctx_free(sid->ctx);
 
 		zebra_srv6_sid_free(sid);
@@ -232,11 +237,16 @@ static void zebra_srv6_sid_entry_del_by_locator(struct zebra_srv6_sid *sid,
 
 void zebra_srv6_sid_entry_del_by_locator_all_sids(struct srv6_locator *locator)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct listnode *node, *nnode;
 	struct zebra_srv6_sid_ctx *ctx;
+	struct zebra_srv6_sid_block *block;
+
+	if (!locator->sid_block)
+		return;
+
+	block = locator->sid_block;
 
-	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx))
+	for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx))
 		zebra_srv6_sid_entry_del_by_locator(ctx->sid, locator);
 }
 
@@ -456,6 +466,10 @@ zebra_srv6_sid_block_alloc(struct srv6_sid_format *format,
 	block->sid_format = format;
 	block->prefix = *prefix;
 
+	/* Init list to store SRv6 SIDs */
+	block->sids = list_new();
+	block->sids->del = delete_zebra_srv6_sid_ctx;
+
 	if (format) {
 		if (format->type == SRV6_SID_FORMAT_TYPE_USID) {
 			uint32_t wlib_start, wlib_end, func;
@@ -585,11 +599,21 @@ static void zebra_srv6_sid_block_refcnt_increment(struct zebra_srv6_sid_block *b
 static void zebra_srv6_sid_block_refcnt_decrement(struct zebra_srv6_sid_block *block)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+	struct listnode *node, *nnode;
+	struct zebra_srv6_sid_ctx *zctx;
 
 	assert(block->refcnt > 0);
 
 	block->refcnt--;
 	if (block->refcnt == 0) {
+		for (ALL_LIST_ELEMENTS(block->sids, node, nnode, zctx)) {
+			if (zctx->sid)
+				zebra_srv6_sid_free(zctx->sid);
+
+			listnode_delete(block->sids, zctx);
+			zebra_srv6_sid_ctx_free(zctx);
+		}
+		list_delete(&block->sids);
 		listnode_delete(srv6->sid_blocks, block);
 		zebra_srv6_sid_block_free(block);
 	}
@@ -624,6 +648,9 @@ void zebra_srv6_sid_locator_block_alloc(struct srv6_locator *locator)
 
 void zebra_srv6_sid_locator_block_release(struct srv6_locator *locator)
 {
+	if (!locator->sid_block)
+		return;
+
 	zebra_srv6_sid_block_refcnt_decrement(locator->sid_block);
 	locator->sid_block = NULL;
 }
@@ -801,9 +828,11 @@ void zebra_srv6_sid_client_del(struct zebra_srv6_sid *sid, struct zebra_srv6_sid
 
 void zebra_srv6_sid_client_del_all(struct zebra_srv6_sid *sid, struct zserv *client)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_entry *entry;
 	struct zebra_srv6_sid_client *zclient;
+	struct zebra_srv6_sid_block *block;
+
+	block = sid->block;
 
 	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry) {
 		zclient = zebra_srv6_sid_client_lookup(sid, entry, client);
@@ -827,7 +856,7 @@ void zebra_srv6_sid_client_del_all(struct zebra_srv6_sid *sid, struct zserv *cli
 		release_srv6_sid_func(sid->ctx);
 
 		/* Remove the SID context from the list and free memory */
-		listnode_delete(srv6->sids, sid->ctx);
+		listnode_delete(block->sids, sid->ctx);
 		zebra_srv6_sid_ctx_free(sid->ctx);
 
 		/* Free the SID */
@@ -1001,10 +1030,6 @@ struct zebra_srv6 *zebra_srv6_get_default(void)
 		format_uncompressed = create_srv6_sid_format_uncompressed();
 		srv6_sid_format_register(format_uncompressed);
 
-		/* Init list to store SRv6 SIDs */
-		g_srv6.sids = list_new();
-		g_srv6.sids->del = delete_zebra_srv6_sid_ctx;
-
 		/* Init list to store SRv6 SID blocks */
 		g_srv6.sid_blocks = list_new();
 		g_srv6.sid_blocks->del = delete_zebra_srv6_sid_block;
@@ -1776,7 +1801,6 @@ static bool alloc_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
 static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
 				 struct in6_addr *sid_value, bool is_localonly)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_ctx *zctx = NULL;
 	uint32_t sid_func = 0, sid_func_wide = 0;
 	struct srv6_locator *locator = NULL;
@@ -1794,7 +1818,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 	}
 
 	/* Check if we already have a SID associated with the provided context */
-	zctx = zebra_srv6_sid_ctx_lookup(ctx);
+	zctx = zebra_srv6_sid_ctx_lookup(ctx, block);
 
 	if (zctx) {
 		/*
@@ -1866,7 +1890,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		(*sid)->wide_func = sid_func_wide;
 		(*sid)->ctx = zctx;
 		zctx->sid = *sid;
-		listnode_add(srv6->sids, zctx);
+		listnode_add(block->sids, zctx);
 	}
 
 	zebra_srv6_sid_entry_add(*sid, locator->name, sid_value, is_localonly);
@@ -1895,7 +1919,6 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
 				struct srv6_locator *locator, bool is_localonly)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_block *block;
 	struct srv6_sid_format *format;
 	struct zebra_srv6_sid_ctx *zctx;
@@ -1913,7 +1936,7 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	 * If we already have a SID for the provided context, we return the existing
 	 * SID instead of allocating a new one.
 	 */
-	zctx = zebra_srv6_sid_ctx_lookup(ctx);
+	zctx = zebra_srv6_sid_ctx_lookup(ctx, block);
 	if (zctx) {
 		if (((format && format->type == SRV6_SID_FORMAT_TYPE_USID) ||
 		     (!format && CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID))) &&
@@ -1962,7 +1985,7 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	}
 	(*sid)->ctx = zctx;
 	zctx->sid = *sid;
-	listnode_add(srv6->sids, zctx);
+	listnode_add(block->sids, zctx);
 
 	zebra_srv6_sid_entry_add(*sid, locator->name, &sid_value, is_localonly);
 
@@ -2475,14 +2498,16 @@ struct zebra_srv6_sid_client *zebra_srv6_sid_client_lookup(struct zebra_srv6_sid
 int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
 		     struct srv6_locator *locator, bool is_localonly)
 {
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	char buf[256];
 	struct zebra_srv6_sid_entry *entry;
 	struct zebra_srv6_sid_client *zclient;
+	struct zebra_srv6_sid_block *block;
 
 	if (!zctx || !zctx->sid)
 		return -1;
 
+	block = zctx->sid->block;
+
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: releasing SRv6 SID func %u associated with ctx %s (proto=%u, instance=%u)",
 			   __func__, zctx->sid->func,
@@ -2529,7 +2554,7 @@ int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
 		zctx->sid = NULL;
 
 		/* Remove the SID context from the list and free memory */
-		listnode_delete(srv6->sids, zctx);
+		listnode_delete(block->sids, zctx);
 		zebra_srv6_sid_ctx_free(zctx);
 	}
 
@@ -2648,8 +2673,10 @@ int release_daemon_srv6_sids(struct zserv *client)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct listnode *node, *nnode;
+	struct listnode *node_block;
 	struct zebra_srv6_sid_ctx *ctx;
 	int count = 0;
+	struct zebra_srv6_sid_block *block;
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: releasing SRv6 SIDs for client proto %s, instance %d, session %u",
@@ -2657,8 +2684,9 @@ int release_daemon_srv6_sids(struct zserv *client)
 			   client->instance, client->session_id);
 
 	/* Iterate over the SIDs and release SIDs used by the client daemon */
-	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx))
-		zebra_srv6_sid_client_del_all(ctx->sid, client);
+	for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block))
+		for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx))
+			zebra_srv6_sid_client_del_all(ctx->sid, client);
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: released %d SRv6 SIDs", __func__, count);
@@ -2679,31 +2707,40 @@ static int srv6_manager_release_sid_internal(struct zserv *client, struct srv6_s
 					     const char *locator_name, bool is_localonly)
 {
 	int ret = -1;
-	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_ctx *zctx;
 	struct listnode *node, *nnode;
 	char buf[256];
 	struct srv6_locator *locator = NULL;
 	struct in6_addr sid_value = {};
+	struct zebra_srv6_sid_block *block = NULL;
+	struct zebra_srv6_sid_entry *entry = NULL;
 
 	if (IS_ZEBRA_DEBUG_SRV6)
 		zlog_debug("%s: releasing SRv6 SID associated with ctx %s",
 			   __func__, srv6_sid_ctx2str(buf, sizeof(buf), ctx));
 
-	if (locator_name && locator_name[0] != '\0') {
-		locator = zebra_srv6_locator_lookup(locator_name);
-		if (!locator) {
-			zlog_err("%s: invalid SM request arguments: SRv6 locator '%s' does not exist",
-				 __func__, locator_name);
-			return -1;
-		}
+	if (!locator_name || locator_name[0] == '\0') {
+		zlog_err("%s: invalid SM request arguments: SRv6 locator not provided", __func__);
+		return -1;
+	}
+
+	locator = zebra_srv6_locator_lookup(locator_name);
+	if (!locator) {
+		if (IS_ZEBRA_DEBUG_SRV6)
+			zlog_debug("%s: SRv6 locator '%s' does not exist", __func__, locator_name);
+		return 0;
 	}
 
+	block = locator->sid_block;
+
 	/* Lookup Zebra SID context and release it */
-	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, zctx))
+	for (ALL_LIST_ELEMENTS(block->sids, node, nnode, zctx))
 		if (memcmp(&zctx->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0) {
-			if (zctx->sid)
-				sid_value = zctx->sid->value;
+			if (zctx->sid) {
+				entry = zebra_srv6_sid_entry_lookup(zctx->sid, locator->name,
+								    is_localonly);
+				sid_value = entry->sid_value;
+			}
 
 			ret = release_srv6_sid(client, zctx, locator, is_localonly);
 			break;
@@ -2741,23 +2778,23 @@ void zebra_srv6_terminate(void)
 		list_delete(&g_srv6.locators);
 	}
 
-	/* Free SRv6 SIDs */
-	if (g_srv6.sids) {
-		while (listcount(g_srv6.sids)) {
-			sid_ctx = listnode_head(g_srv6.sids);
-
-			listnode_delete(g_srv6.sids, sid_ctx);
-			zebra_srv6_sid_ctx_free(sid_ctx);
-		}
-
-		list_delete(&g_srv6.sids);
-	}
-
 	/* Free SRv6 SID blocks */
 	if (g_srv6.sid_blocks) {
 		while (listcount(g_srv6.sid_blocks)) {
 			block = listnode_head(g_srv6.sid_blocks);
 
+			/* Free SRv6 SIDs */
+			while (listcount(block->sids)) {
+				sid_ctx = listnode_head(block->sids);
+
+				zebra_srv6_sid_free(sid_ctx->sid);
+
+				listnode_delete(block->sids, sid_ctx);
+				zebra_srv6_sid_ctx_free(sid_ctx);
+			}
+
+			list_delete(&block->sids);
+
 			listnode_delete(g_srv6.sid_blocks, block);
 			zebra_srv6_sid_block_free(block);
 		}
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 15819c471fd6..374ff7e97637 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -113,6 +113,9 @@ struct zebra_srv6_sid_block {
 			struct list *func_released;
 		} uncompressed;
 	} u;
+
+	/* SRv6 SIDs */
+	struct list *sids;
 };
 
 /**
@@ -232,9 +235,6 @@ struct zebra_srv6 {
 	/* SRv6 SID formats */
 	struct list *sid_formats;
 
-	/* SRv6 SIDs */
-	struct list *sids;
-
 	/* SRv6 SID blocks */
 	struct list *sid_blocks;
 };
@@ -370,6 +370,7 @@ extern int srv6_manager_get_sid_response(struct zebra_srv6_sid *sid,
 extern struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_alloc(void);
 extern void zebra_srv6_sid_ctx_free(struct zebra_srv6_sid_ctx *ctx);
 extern void delete_zebra_srv6_sid_ctx(void *val);
-extern struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_lookup(const struct srv6_sid_ctx *ctx);
+extern struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_lookup(const struct srv6_sid_ctx *ctx,
+							    struct zebra_srv6_sid_block *block);
 
 #endif /* _ZEBRA_SRV6_H */
diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index 207ceb90c99d..61d163b2a9fd 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -561,21 +561,25 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 	struct zebra_srv6_sid_ctx *ctx;
 	struct listnode *node;
 	struct ttable *tt;
+	struct zebra_srv6_sid_block *block;
+	struct listnode *node_block;
 	char *table;
 
 	if (json) {
-		for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, ctx)) {
-			/* Skip contexts not associated with any SID */
-			if (!ctx->sid)
-				continue;
+		for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block)) {
+			for (ALL_LIST_ELEMENTS_RO(block->sids, node, ctx)) {
+				/* Skip contexts not associated with any SID */
+				if (!ctx->sid)
+					continue;
 
-			/* Skip SIDs from locators we are not interested in */
-			if (locator &&
-			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
-			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
-				continue;
+				/* Skip SIDs from locators we are not interested in */
+				if (locator &&
+				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
+				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
+					continue;
 
-			do_show_srv6_sid_json(vty, json, locator, ctx);
+				do_show_srv6_sid_json(vty, json, locator, ctx);
+			}
 		}
 	} else {
 		/* Prepare table. */
@@ -586,18 +590,20 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 		ttable_restyle(tt);
 		ttable_rowseps(tt, 0, BOTTOM, true, '-');
 
-		for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, ctx)) {
-			/* Skip contexts not associated with any SID */
-			if (!ctx->sid)
-				continue;
+		for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block)) {
+			for (ALL_LIST_ELEMENTS_RO(block->sids, node, ctx)) {
+				/* Skip contexts not associated with any SID */
+				if (!ctx->sid)
+					continue;
 
-			/* Skip SIDs from locators we are not interested in */
-			if (locator &&
-			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
-			    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
-				continue;
+				/* Skip SIDs from locators we are not interested in */
+				if (locator &&
+				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
+				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
+					continue;
 
-			do_show_srv6_sid_line(tt, ctx->sid);
+				do_show_srv6_sid_line(tt, ctx->sid);
+			}
 		}
 
 		ttable_colseps(tt, 1, RIGHT, true, ' ');
@@ -637,6 +643,8 @@ DEFPY (show_srv6_sid,
 	json_object *json = NULL;
 	bool found = false;
 	struct zebra_srv6_sid_entry *entry;
+	struct zebra_srv6_sid_block *block = NULL;
+	struct listnode *node_block;
 
 	if (uj)
 		json = json_object_new_object();
@@ -653,18 +661,21 @@ DEFPY (show_srv6_sid,
 	}
 
 	if (!IPV6_ADDR_SAME(&sid_value, &in6addr_any)) {
-		for (ALL_LIST_ELEMENTS_RO(srv6->sids, node, c)) {
-			if (!c->sid)
-				continue;
+		for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block)) {
+			for (ALL_LIST_ELEMENTS_RO(block->sids, node, c)) {
+				if (!c->sid)
+					continue;
 
-			frr_each_safe (zebra_srv6_sid_entry_list, &c->sid->entries, entry) {
-				if (IPV6_ADDR_SAME(&entry->sid_value, &sid_value)) {
-					sid_ctx = c;
-					break;
+				frr_each_safe (zebra_srv6_sid_entry_list, &c->sid->entries, entry) {
+					if (IPV6_ADDR_SAME(&entry->sid_value, &sid_value)) {
+						sid_ctx = c;
+						break;
+					}
 				}
 			}
 		}
 
+
 		if (!sid_ctx) {
 			if (uj)
 				vty_json(vty, json); /* Return empty json */
@@ -731,19 +742,19 @@ DEFUN (no_srv6,
 	struct zebra_srv6_sid_block *block;
 	struct zebra_srv6_sid_ctx *ctx;
 
-	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx)) {
-		if (ctx->sid)
-			zebra_srv6_sid_free(ctx->sid);
-
-		listnode_delete(srv6->sids, ctx);
-		zebra_srv6_sid_ctx_free(ctx);
-	}
-
 	for (ALL_LIST_ELEMENTS(srv6->locators, node, nnode, locator)) {
 		block = locator->sid_block;
 		if (block) {
 			block->refcnt--;
 			if (block->refcnt == 0) {
+				for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx)) {
+					if (ctx->sid)
+						zebra_srv6_sid_free(ctx->sid);
+
+					listnode_delete(block->sids, ctx);
+					zebra_srv6_sid_ctx_free(ctx);
+				}
+				list_delete(&block->sids);
 				listnode_delete(srv6->sid_blocks, block);
 				zebra_srv6_sid_block_free(block);
 			}
@@ -806,7 +817,8 @@ DEFUN (no_srv6_locator,
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
-	for (ALL_LIST_ELEMENTS(srv6->sids, node, nnode, ctx)) {
+	block = locator->sid_block;
+	for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx)) {
 		if (!ctx->sid)
 			continue;
 
@@ -819,7 +831,7 @@ DEFUN (no_srv6_locator,
 		if (zebra_srv6_sid_entry_list_count(&ctx->sid->entries) == 0) {
 			zebra_srv6_sid_free(ctx->sid);
 
-			listnode_delete(srv6->sids, ctx);
+			listnode_delete(block->sids, ctx);
 			zebra_srv6_sid_ctx_free(ctx);
 		}
 	}
@@ -828,6 +840,14 @@ DEFUN (no_srv6_locator,
 	if (block) {
 		block->refcnt--;
 		if (block->refcnt == 0) {
+			for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx)) {
+				if (ctx->sid)
+					zebra_srv6_sid_free(ctx->sid);
+
+				listnode_delete(block->sids, ctx);
+				zebra_srv6_sid_ctx_free(ctx);
+			}
+			list_delete(&block->sids);
 			listnode_delete(srv6->sid_blocks, block);
 			zebra_srv6_sid_block_free(block);
 		}

From 23d8cd405e5c8acbded2eb7d4c97afbfccee4127 Mon Sep 17 00:00:00 2001
From: Philippe Guibert <philippe.guibert@6wind.com>
Date: Thu, 26 Jun 2025 12:21:05 +0200
Subject: [PATCH 19/25] zebra: fix display 'show segment-routing srv6 locator
 LOC1 sid' output

The 'show segment-routing srv6 locator LOC1 sid' output displays
information from other locators.

The current procedure displays all entries if at least one entry belongs
to the passed locator. Fix this by passing the locator parameter to the
function in charge of displaying the list.

Signed-off-by: Philippe Guibert <philippe.guibert@6wind.com>
---
 zebra/zebra_srv6_vty.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index 61d163b2a9fd..64439f8e2537 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -340,7 +340,8 @@ static const char *show_srv6_sid_seg6_context(char *str, size_t size, const stru
 	return str;
 }
 
-static void do_show_srv6_sid_line(struct ttable *tt, struct zebra_srv6_sid *sid)
+static void do_show_srv6_sid_line(struct ttable *tt, struct zebra_srv6_sid *sid,
+				  struct srv6_locator *locator)
 {
 	struct zserv *client;
 	char clients[256];
@@ -353,6 +354,8 @@ static void do_show_srv6_sid_line(struct ttable *tt, struct zebra_srv6_sid *sid)
 	int ret;
 
 	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry) {
+		if (locator && locator != entry->locator)
+			continue;
 		/* Zclients */
 		if (zebra_srv6_sid_client_list_count(&entry->clients_list)) {
 			bool first = true;
@@ -532,7 +535,7 @@ static void do_show_srv6_sid_specific(struct vty *vty, json_object **json,
 				return;
 		}
 
-		do_show_srv6_sid_line(tt, sid_ctx->sid);
+		do_show_srv6_sid_line(tt, sid_ctx->sid, locator);
 
 		ttable_colseps(tt, 1, RIGHT, true, ' ');
 		ttable_colseps(tt, 2, LEFT, true, ' ');
@@ -601,8 +604,7 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
 				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
 					continue;
-
-				do_show_srv6_sid_line(tt, ctx->sid);
+				do_show_srv6_sid_line(tt, ctx->sid, locator);
 			}
 		}
 

From 96e52b6f7d3c2d17074a88b8407db0878ccdd147 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 27 Jun 2025 11:37:24 +0000
Subject: [PATCH 20/25] zebra: Fix display 'show segment-routing srv6 sid
 fcbb:bb01:1:fe10::' output

The 'show segment-routing srv6 locator sid fcbb:bb01:1:fe10::' output
displays information from other SIDs.

The current procedure displays all entries if at least one entry
belongs to the passed SID. Fix this by passing the SID value parameter
to the function in charge of displaying the list.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6_vty.c | 28 ++++++++++++++++++----------
 1 file changed, 18 insertions(+), 10 deletions(-)

diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index 64439f8e2537..efdd2607dbcc 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -341,7 +341,7 @@ static const char *show_srv6_sid_seg6_context(char *str, size_t size, const stru
 }
 
 static void do_show_srv6_sid_line(struct ttable *tt, struct zebra_srv6_sid *sid,
-				  struct srv6_locator *locator)
+				  struct in6_addr *sid_value, struct srv6_locator *locator)
 {
 	struct zserv *client;
 	char clients[256];
@@ -356,6 +356,10 @@ static void do_show_srv6_sid_line(struct ttable *tt, struct zebra_srv6_sid *sid,
 	frr_each_safe (zebra_srv6_sid_entry_list, &sid->entries, entry) {
 		if (locator && locator != entry->locator)
 			continue;
+
+		if (sid_value && !sid_same(sid_value, &entry->sid_value))
+			continue;
+
 		/* Zclients */
 		if (zebra_srv6_sid_client_list_count(&entry->clients_list)) {
 			bool first = true;
@@ -413,7 +417,7 @@ static void do_show_srv6_sid_line(struct ttable *tt, struct zebra_srv6_sid *sid,
 }
 
 static void do_show_srv6_sid_json(struct vty *vty, json_object **json, struct srv6_locator *locator,
-				  struct zebra_srv6_sid_ctx *sid_ctx)
+				  struct zebra_srv6_sid_ctx *sid_ctx, struct in6_addr *sid_value)
 {
 	json_object *json_sid_ctx = NULL;
 	json_object *json_sid = NULL;
@@ -432,7 +436,10 @@ static void do_show_srv6_sid_json(struct vty *vty, json_object **json, struct sr
 
 	frr_each (zebra_srv6_sid_entry_list, &sid_ctx->sid->entries, entry) {
 		if (locator && entry->locator != locator)
-			return;
+			continue;
+
+		if (sid_value && !sid_same(sid_value, &entry->sid_value))
+			continue;
 
 		json_sid = json_object_new_object();
 		json_sid_ctx = json_object_new_object();
@@ -501,14 +508,15 @@ static void do_show_srv6_sid_json(struct vty *vty, json_object **json, struct sr
 
 static void do_show_srv6_sid_specific(struct vty *vty, json_object **json,
 				      struct srv6_locator *locator,
-				      struct zebra_srv6_sid_ctx *sid_ctx)
+				      struct zebra_srv6_sid_ctx *sid_ctx,
+				      struct in6_addr *sid_value)
 {
 	struct ttable *tt;
 	struct zebra_srv6_sid_entry *entry;
 	bool found = false;
 
 	if (json) {
-		do_show_srv6_sid_json(vty, json, locator, sid_ctx);
+		do_show_srv6_sid_json(vty, json, locator, sid_ctx, sid_value);
 	} else {
 		/* Prepare table. */
 		tt = ttable_new(&ttable_styles[TTSTYLE_BLANK]);
@@ -535,7 +543,7 @@ static void do_show_srv6_sid_specific(struct vty *vty, json_object **json,
 				return;
 		}
 
-		do_show_srv6_sid_line(tt, sid_ctx->sid, locator);
+		do_show_srv6_sid_line(tt, sid_ctx->sid, sid_value, locator);
 
 		ttable_colseps(tt, 1, RIGHT, true, ' ');
 		ttable_colseps(tt, 2, LEFT, true, ' ');
@@ -581,7 +589,7 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
 					continue;
 
-				do_show_srv6_sid_json(vty, json, locator, ctx);
+				do_show_srv6_sid_json(vty, json, locator, ctx, NULL);
 			}
 		}
 	} else {
@@ -604,7 +612,7 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, false) &&
 				    !zebra_srv6_sid_entry_lookup(ctx->sid, locator->name, true))
 					continue;
-				do_show_srv6_sid_line(tt, ctx->sid, locator);
+				do_show_srv6_sid_line(tt, ctx->sid, NULL, locator);
 			}
 		}
 
@@ -703,8 +711,8 @@ DEFPY (show_srv6_sid,
 		}
 	}
 
-	if (sid_ctx)
-		do_show_srv6_sid_specific(vty, uj ? &json : NULL, locator, sid_ctx);
+	if (!IPV6_ADDR_SAME(&sid_value, &in6addr_any))
+		do_show_srv6_sid_specific(vty, uj ? &json : NULL, locator, sid_ctx, &sid_value);
 	else
 		do_show_srv6_sid_all(vty, uj ? &json : NULL, locator);
 

From f404b17e9ffb96ba55a71c6b4c52f7dc8c386f7a Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sat, 7 Jun 2025 00:04:41 +0000
Subject: [PATCH 21/25] zebra: Verify SRv6 parent locator before allocating an
 explicit SID

When daemons request SID Manager to allocate a SID, they can specify
the parent locator from which the SID has to be allocated. Currently,
in the case of explicit allocation, SID Manager ignores the parent
locator provided by daemons.

This commit extends SID Manager to take the parent locator in
consideration. Specifically, when SID Manager gets a request to
allocate an explicit SID, it checks that the requested SID comes from
the provided parent locator. If not, SID Manager considers the request
malformed and rejects the request.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c | 24 +++++++++++++++++++-----
 1 file changed, 19 insertions(+), 5 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 6e3389c3ced5..08fec8023859 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -1791,6 +1791,7 @@ static bool alloc_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
  *
  * @param sid SID returned
  * @param ctx Context for which the SID has been requested
+ * @param locator Parent locator of the SID
  * @param sid_value specific SRv6 SID value (i.e. IPv6 address) to be
  * allocated explicitly
  * @param is_localonly SID is local-only
@@ -1799,11 +1800,12 @@ static bool alloc_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
  * 1 if a new SID has been allocated or the existing SID value has changed, -1 if an error occurred
  */
 static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
-				 struct in6_addr *sid_value, bool is_localonly)
+				 struct srv6_locator *locator, struct in6_addr *sid_value,
+				 bool is_localonly)
 {
 	struct zebra_srv6_sid_ctx *zctx = NULL;
 	uint32_t sid_func = 0, sid_func_wide = 0;
-	struct srv6_locator *locator = NULL;
+	struct srv6_locator *loc = NULL;
 	struct zebra_srv6_sid_block *block = NULL;
 	char buf[256];
 
@@ -1811,12 +1813,15 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		return -1;
 
 	/* Get parent locator and function of the provided SID */
-	if (!zebra_srv6_sid_decompose(sid_value, &block, &locator, &sid_func, &sid_func_wide)) {
+	if (!zebra_srv6_sid_decompose(sid_value, &block, &loc, &sid_func, &sid_func_wide)) {
 		zlog_err("%s: invalid SM request arguments: parent block/locator not found for SID %pI6",
 			 __func__, sid_value);
 		return -1;
 	}
 
+	if (!locator)
+		locator = loc;
+
 	/* Check if we already have a SID associated with the provided context */
 	zctx = zebra_srv6_sid_ctx_lookup(ctx, block);
 
@@ -2020,7 +2025,7 @@ int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx, struct i
 		 const char *locator_name, bool is_localonly)
 {
 	int ret = -1;
-	struct srv6_locator *locator;
+	struct srv6_locator *locator = NULL;
 	char buf[256];
 	struct nhg_connected *rb_node_dep = NULL;
 	struct listnode *node;
@@ -2082,13 +2087,22 @@ int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx, struct i
 		 * Explicit SID allocation: allocate a specific SID value
 		 */
 
+		if (locator_name) {
+			locator = zebra_srv6_locator_lookup(locator_name);
+			if (!locator) {
+				zlog_err("%s: invalid SM request arguments: SRv6 locator '%s' does not exist",
+					 __func__, locator_name);
+				return -1;
+			}
+		}
+
 		if (!sid_value) {
 			zlog_err("%s: invalid SM request arguments: missing SRv6 SID value, necessary for explicit allocation",
 				 __func__);
 			return -1;
 		}
 
-		ret = get_srv6_sid_explicit(sid, ctx, sid_value, is_localonly);
+		ret = get_srv6_sid_explicit(sid, ctx, locator, sid_value, is_localonly);
 	} else {
 		/*
 		 * Dynamic SID allocation: allocate any available SID value

From 498af7a819446997477f138530c4e74992e9caee Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sat, 14 Jun 2025 05:50:24 +0000
Subject: [PATCH 22/25] zebra: Convert `srv6_sids` to double-linked list

Convert srv6_sids data structure from `struct list` to type-safe
double-linked list.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 zebra/zebra_srv6.c     | 40 +++++++++++++++++-----------------------
 zebra/zebra_srv6.h     |  8 +++++++-
 zebra/zebra_srv6_vty.c | 25 +++++++++++--------------
 3 files changed, 35 insertions(+), 38 deletions(-)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 08fec8023859..0a8b8b3605db 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -169,9 +169,8 @@ struct zebra_srv6_sid_ctx *zebra_srv6_sid_ctx_lookup(const struct srv6_sid_ctx *
 						     struct zebra_srv6_sid_block *block)
 {
 	struct zebra_srv6_sid_ctx *zctx;
-	struct listnode *node;
 
-	for (ALL_LIST_ELEMENTS_RO(block->sids, node, zctx))
+	frr_each (zebra_srv6_sid_ctx_list, &block->sids, zctx)
 		if (memcmp(&zctx->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0)
 			return zctx;
 
@@ -228,7 +227,7 @@ static void zebra_srv6_sid_entry_del_by_locator(struct zebra_srv6_sid *sid,
 		}
 
 	if (zebra_srv6_sid_entry_list_count(&sid->entries) == 0) {
-		listnode_delete(block->sids, sid->ctx);
+		zebra_srv6_sid_ctx_list_del(&block->sids, sid->ctx);
 		zebra_srv6_sid_ctx_free(sid->ctx);
 
 		zebra_srv6_sid_free(sid);
@@ -237,7 +236,6 @@ static void zebra_srv6_sid_entry_del_by_locator(struct zebra_srv6_sid *sid,
 
 void zebra_srv6_sid_entry_del_by_locator_all_sids(struct srv6_locator *locator)
 {
-	struct listnode *node, *nnode;
 	struct zebra_srv6_sid_ctx *ctx;
 	struct zebra_srv6_sid_block *block;
 
@@ -246,7 +244,7 @@ void zebra_srv6_sid_entry_del_by_locator_all_sids(struct srv6_locator *locator)
 
 	block = locator->sid_block;
 
-	for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx))
+	frr_each_safe (zebra_srv6_sid_ctx_list, &block->sids, ctx)
 		zebra_srv6_sid_entry_del_by_locator(ctx->sid, locator);
 }
 
@@ -467,8 +465,7 @@ zebra_srv6_sid_block_alloc(struct srv6_sid_format *format,
 	block->prefix = *prefix;
 
 	/* Init list to store SRv6 SIDs */
-	block->sids = list_new();
-	block->sids->del = delete_zebra_srv6_sid_ctx;
+	zebra_srv6_sid_ctx_list_init(&block->sids);
 
 	if (format) {
 		if (format->type == SRV6_SID_FORMAT_TYPE_USID) {
@@ -599,21 +596,20 @@ static void zebra_srv6_sid_block_refcnt_increment(struct zebra_srv6_sid_block *b
 static void zebra_srv6_sid_block_refcnt_decrement(struct zebra_srv6_sid_block *block)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
-	struct listnode *node, *nnode;
 	struct zebra_srv6_sid_ctx *zctx;
 
 	assert(block->refcnt > 0);
 
 	block->refcnt--;
 	if (block->refcnt == 0) {
-		for (ALL_LIST_ELEMENTS(block->sids, node, nnode, zctx)) {
+		frr_each_safe (zebra_srv6_sid_ctx_list, &block->sids, zctx) {
 			if (zctx->sid)
 				zebra_srv6_sid_free(zctx->sid);
 
-			listnode_delete(block->sids, zctx);
+			zebra_srv6_sid_ctx_list_del(&block->sids, zctx);
 			zebra_srv6_sid_ctx_free(zctx);
 		}
-		list_delete(&block->sids);
+		zebra_srv6_sid_ctx_list_fini(&block->sids);
 		listnode_delete(srv6->sid_blocks, block);
 		zebra_srv6_sid_block_free(block);
 	}
@@ -856,7 +852,7 @@ void zebra_srv6_sid_client_del_all(struct zebra_srv6_sid *sid, struct zserv *cli
 		release_srv6_sid_func(sid->ctx);
 
 		/* Remove the SID context from the list and free memory */
-		listnode_delete(block->sids, sid->ctx);
+		zebra_srv6_sid_ctx_list_del(&block->sids, sid->ctx);
 		zebra_srv6_sid_ctx_free(sid->ctx);
 
 		/* Free the SID */
@@ -1895,7 +1891,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid, struct srv6_sid_ct
 		(*sid)->wide_func = sid_func_wide;
 		(*sid)->ctx = zctx;
 		zctx->sid = *sid;
-		listnode_add(block->sids, zctx);
+		zebra_srv6_sid_ctx_list_add_tail(&block->sids, zctx);
 	}
 
 	zebra_srv6_sid_entry_add(*sid, locator->name, sid_value, is_localonly);
@@ -1990,7 +1986,7 @@ static int get_srv6_sid_dynamic(struct zebra_srv6_sid **sid, struct srv6_sid_ctx
 	}
 	(*sid)->ctx = zctx;
 	zctx->sid = *sid;
-	listnode_add(block->sids, zctx);
+	zebra_srv6_sid_ctx_list_add_tail(&block->sids, zctx);
 
 	zebra_srv6_sid_entry_add(*sid, locator->name, &sid_value, is_localonly);
 
@@ -2568,7 +2564,7 @@ int release_srv6_sid(struct zserv *client, struct zebra_srv6_sid_ctx *zctx,
 		zctx->sid = NULL;
 
 		/* Remove the SID context from the list and free memory */
-		listnode_delete(block->sids, zctx);
+		zebra_srv6_sid_ctx_list_del(&block->sids, zctx);
 		zebra_srv6_sid_ctx_free(zctx);
 	}
 
@@ -2686,7 +2682,6 @@ static int srv6_manager_get_sid_internal(struct zebra_srv6_sid **sid, struct zse
 int release_daemon_srv6_sids(struct zserv *client)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
-	struct listnode *node, *nnode;
 	struct listnode *node_block;
 	struct zebra_srv6_sid_ctx *ctx;
 	int count = 0;
@@ -2699,7 +2694,7 @@ int release_daemon_srv6_sids(struct zserv *client)
 
 	/* Iterate over the SIDs and release SIDs used by the client daemon */
 	for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block))
-		for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx))
+		frr_each_safe (zebra_srv6_sid_ctx_list, &block->sids, ctx)
 			zebra_srv6_sid_client_del_all(ctx->sid, client);
 
 	if (IS_ZEBRA_DEBUG_SRV6)
@@ -2722,7 +2717,6 @@ static int srv6_manager_release_sid_internal(struct zserv *client, struct srv6_s
 {
 	int ret = -1;
 	struct zebra_srv6_sid_ctx *zctx;
-	struct listnode *node, *nnode;
 	char buf[256];
 	struct srv6_locator *locator = NULL;
 	struct in6_addr sid_value = {};
@@ -2748,7 +2742,7 @@ static int srv6_manager_release_sid_internal(struct zserv *client, struct srv6_s
 	block = locator->sid_block;
 
 	/* Lookup Zebra SID context and release it */
-	for (ALL_LIST_ELEMENTS(block->sids, node, nnode, zctx))
+	frr_each_safe (zebra_srv6_sid_ctx_list, &block->sids, zctx)
 		if (memcmp(&zctx->ctx, ctx, sizeof(struct srv6_sid_ctx)) == 0) {
 			if (zctx->sid) {
 				entry = zebra_srv6_sid_entry_lookup(zctx->sid, locator->name,
@@ -2798,16 +2792,16 @@ void zebra_srv6_terminate(void)
 			block = listnode_head(g_srv6.sid_blocks);
 
 			/* Free SRv6 SIDs */
-			while (listcount(block->sids)) {
-				sid_ctx = listnode_head(block->sids);
+			while (zebra_srv6_sid_ctx_list_count(&block->sids)) {
+				sid_ctx = zebra_srv6_sid_ctx_list_first(&block->sids);
 
 				zebra_srv6_sid_free(sid_ctx->sid);
 
-				listnode_delete(block->sids, sid_ctx);
+				zebra_srv6_sid_ctx_list_del(&block->sids, sid_ctx);
 				zebra_srv6_sid_ctx_free(sid_ctx);
 			}
 
-			list_delete(&block->sids);
+			zebra_srv6_sid_ctx_list_fini(&block->sids);
 
 			listnode_delete(g_srv6.sid_blocks, block);
 			zebra_srv6_sid_block_free(block);
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 374ff7e97637..47511baa2ffd 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -60,6 +60,8 @@ struct wide_lib {
 	struct list *func_released;
 };
 
+PREDECL_DLIST(zebra_srv6_sid_ctx_list);
+
 /*
  * SRv6 SID block.
  *
@@ -115,7 +117,7 @@ struct zebra_srv6_sid_block {
 	} u;
 
 	/* SRv6 SIDs */
-	struct list *sids;
+	struct zebra_srv6_sid_ctx_list_head sids;
 };
 
 /**
@@ -223,8 +225,12 @@ struct zebra_srv6_sid_ctx {
 
 	/* SID associated with the context. */
 	struct zebra_srv6_sid *sid;
+
+	struct zebra_srv6_sid_ctx_list_item item;
 };
 
+DECLARE_DLIST(zebra_srv6_sid_ctx_list, struct zebra_srv6_sid_ctx, item);
+
 /* SRv6 instance structure. */
 struct zebra_srv6 {
 	struct list *locators;
diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index efdd2607dbcc..59a15d93070c 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -570,7 +570,6 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_ctx *ctx;
-	struct listnode *node;
 	struct ttable *tt;
 	struct zebra_srv6_sid_block *block;
 	struct listnode *node_block;
@@ -578,7 +577,7 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 
 	if (json) {
 		for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block)) {
-			for (ALL_LIST_ELEMENTS_RO(block->sids, node, ctx)) {
+			frr_each (zebra_srv6_sid_ctx_list, &block->sids, ctx) {
 				/* Skip contexts not associated with any SID */
 				if (!ctx->sid)
 					continue;
@@ -602,7 +601,7 @@ static void do_show_srv6_sid_all(struct vty *vty, json_object **json, struct srv
 		ttable_rowseps(tt, 0, BOTTOM, true, '-');
 
 		for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block)) {
-			for (ALL_LIST_ELEMENTS_RO(block->sids, node, ctx)) {
+			frr_each (zebra_srv6_sid_ctx_list, &block->sids, ctx) {
 				/* Skip contexts not associated with any SID */
 				if (!ctx->sid)
 					continue;
@@ -649,7 +648,6 @@ DEFPY (show_srv6_sid,
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct srv6_locator *locator = NULL;
 	struct zebra_srv6_sid_ctx *sid_ctx = NULL, *c;
-	struct listnode *node;
 	json_object *json = NULL;
 	bool found = false;
 	struct zebra_srv6_sid_entry *entry;
@@ -672,7 +670,7 @@ DEFPY (show_srv6_sid,
 
 	if (!IPV6_ADDR_SAME(&sid_value, &in6addr_any)) {
 		for (ALL_LIST_ELEMENTS_RO(srv6->sid_blocks, node_block, block)) {
-			for (ALL_LIST_ELEMENTS_RO(block->sids, node, c)) {
+			frr_each (zebra_srv6_sid_ctx_list, &block->sids, c) {
 				if (!c->sid)
 					continue;
 
@@ -757,14 +755,14 @@ DEFUN (no_srv6,
 		if (block) {
 			block->refcnt--;
 			if (block->refcnt == 0) {
-				for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx)) {
+				frr_each_safe (zebra_srv6_sid_ctx_list, &block->sids, ctx) {
 					if (ctx->sid)
 						zebra_srv6_sid_free(ctx->sid);
 
-					listnode_delete(block->sids, ctx);
+					zebra_srv6_sid_ctx_list_del(&block->sids, ctx);
 					zebra_srv6_sid_ctx_free(ctx);
 				}
-				list_delete(&block->sids);
+				zebra_srv6_sid_ctx_list_fini(&block->sids);
 				listnode_delete(srv6->sid_blocks, block);
 				zebra_srv6_sid_block_free(block);
 			}
@@ -817,7 +815,6 @@ DEFUN (no_srv6_locator,
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_block *block;
-	struct listnode *node, *nnode;
 	struct zebra_srv6_sid_ctx *ctx;
 	struct srv6_locator *locator = zebra_srv6_locator_lookup(argv[2]->arg);
 	struct zebra_srv6_sid_entry *entry;
@@ -828,7 +825,7 @@ DEFUN (no_srv6_locator,
 	}
 
 	block = locator->sid_block;
-	for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx)) {
+	frr_each_safe (zebra_srv6_sid_ctx_list, &block->sids, ctx) {
 		if (!ctx->sid)
 			continue;
 
@@ -841,7 +838,7 @@ DEFUN (no_srv6_locator,
 		if (zebra_srv6_sid_entry_list_count(&ctx->sid->entries) == 0) {
 			zebra_srv6_sid_free(ctx->sid);
 
-			listnode_delete(block->sids, ctx);
+			zebra_srv6_sid_ctx_list_del(&block->sids, ctx);
 			zebra_srv6_sid_ctx_free(ctx);
 		}
 	}
@@ -850,14 +847,14 @@ DEFUN (no_srv6_locator,
 	if (block) {
 		block->refcnt--;
 		if (block->refcnt == 0) {
-			for (ALL_LIST_ELEMENTS(block->sids, node, nnode, ctx)) {
+			frr_each_safe (zebra_srv6_sid_ctx_list, &block->sids, ctx) {
 				if (ctx->sid)
 					zebra_srv6_sid_free(ctx->sid);
 
-				listnode_delete(block->sids, ctx);
+				zebra_srv6_sid_ctx_list_del(&block->sids, ctx);
 				zebra_srv6_sid_ctx_free(ctx);
 			}
-			list_delete(&block->sids);
+			zebra_srv6_sid_ctx_list_fini(&block->sids);
 			listnode_delete(srv6->sid_blocks, block);
 			zebra_srv6_sid_block_free(block);
 		}

From 151147400dc77d6470eb9b96221dbd43833a1258 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Thu, 26 Jun 2025 14:43:03 +0000
Subject: [PATCH 23/25] staticd: Extend SRv6 SID uninstall to provide behavior
 and context

Currently, staticd does not provide behavior and context information
when it uninstalls an SRv6 SID.

This can make debugging and troubleshooting tricky for an operator,
as there is no way to know information about the sid that is going
to be deleted.

For example:

```
2025/06/19 17:15:10.632888 STATIC: [HSZRA-C8FAP] static_zebra_send_localsid:  |- Delete SRv6 SID fcbb:bb01:fff7:fe50:: behavior unspec
```

This commit extends staticd to provide action and context when
uninstalling an SRv6 SID.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 staticd/static_zebra.c | 78 +++++++++++++++++++++++++++++++++++++++---
 1 file changed, 74 insertions(+), 4 deletions(-)

diff --git a/staticd/static_zebra.c b/staticd/static_zebra.c
index b02156c847ec..28c2a42008e8 100644
--- a/staticd/static_zebra.c
+++ b/staticd/static_zebra.c
@@ -838,19 +838,48 @@ void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
 	}
 
 	switch (sid->behavior) {
-	case SRV6_ENDPOINT_BEHAVIOR_END:
 	case SRV6_ENDPOINT_BEHAVIOR_END_PSP:
-	case SRV6_ENDPOINT_BEHAVIOR_END_NEXT_CSID:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END;
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_PSP);
+		break;
+	case SRV6_ENDPOINT_BEHAVIOR_END:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END;
+		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_NEXT_CSID_PSP:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END;
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_PSP);
+		break;
+	case SRV6_ENDPOINT_BEHAVIOR_END_NEXT_CSID:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END;
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_DT6:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf_is_enabled(vrf)) {
+			zlog_warn("Failed to install SID %pFX: VRF %s is inactive", &sid->addr,
+				  sid->attributes.vrf_name);
+			return;
+		}
+		ctx.table = vrf->data.l.table_id;
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("Failed to install SID %pFX: failed to get loopback for vrf %s",
+				  &sid->addr, sid->attributes.vrf_name);
+			return;
+		}
+		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_DT6_USID:
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
 		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
 		if (!vrf_is_enabled(vrf)) {
 			zlog_warn("Failed to install SID %pFX: VRF %s is inactive", &sid->addr,
 				  sid->attributes.vrf_name);
 			return;
 		}
+		ctx.table = vrf->data.l.table_id;
 		ifp = if_get_vrf_loopback(vrf->vrf_id);
 		if (!ifp) {
 			zlog_warn("Failed to install SID %pFX: failed to get loopback for vrf %s",
@@ -859,13 +888,31 @@ void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
 		}
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_DT4:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT4;
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf_is_enabled(vrf)) {
+			zlog_warn("Failed to install SID %pFX: VRF %s is inactive", &sid->addr,
+				  sid->attributes.vrf_name);
+			return;
+		}
+		ctx.table = vrf->data.l.table_id;
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("Failed to install SID %pFX: failed to get loopback for vrf %s",
+				  &sid->addr, sid->attributes.vrf_name);
+			return;
+		}
+		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_DT4_USID:
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT4;
 		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
 		if (!vrf_is_enabled(vrf)) {
 			zlog_warn("Failed to install SID %pFX: VRF %s is inactive", &sid->addr,
 				  sid->attributes.vrf_name);
 			return;
 		}
+		ctx.table = vrf->data.l.table_id;
 		ifp = if_get_vrf_loopback(vrf->vrf_id);
 		if (!ifp) {
 			zlog_warn("Failed to install SID %pFX: failed to get loopback for vrf %s",
@@ -874,13 +921,31 @@ void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
 		}
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_DT46:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf_is_enabled(vrf)) {
+			zlog_warn("Failed to install SID %pFX: VRF %s is inactive", &sid->addr,
+				  sid->attributes.vrf_name);
+			return;
+		}
+		ctx.table = vrf->data.l.table_id;
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("Failed to install SID %pFX: failed to get loopback for vrf %s",
+				  &sid->addr, sid->attributes.vrf_name);
+			return;
+		}
+		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_DT46_USID:
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
 		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
 		if (!vrf_is_enabled(vrf)) {
 			zlog_warn("Failed to install SID %pFX: VRF %s is inactive", &sid->addr,
 				  sid->attributes.vrf_name);
 			return;
 		}
+		ctx.table = vrf->data.l.table_id;
 		ifp = if_get_vrf_loopback(vrf->vrf_id);
 		if (!ifp) {
 			zlog_warn("Failed to install SID %pFX: failed to get loopback for vrf %s",
@@ -889,6 +954,7 @@ void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
 		}
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_X_NEXT_CSID:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_X;
 		ctx.nh6 = sid->attributes.nh6;
 		ifp = if_lookup_by_name(sid->attributes.ifname, VRF_DEFAULT);
 		if (!ifp) {
@@ -896,6 +962,7 @@ void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
 				  &sid->addr, sid->attributes.ifname);
 			return;
 		}
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops, ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
 		break;
 	case SRV6_ENDPOINT_BEHAVIOR_END_PSP_USD:
 	case SRV6_ENDPOINT_BEHAVIOR_END_NEXT_CSID_PSP_USD:
@@ -904,12 +971,12 @@ void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
 	case SRV6_ENDPOINT_BEHAVIOR_END_X_PSP_USD:
 	case SRV6_ENDPOINT_BEHAVIOR_END_X_NEXT_CSID_PSP:
 	case SRV6_ENDPOINT_BEHAVIOR_END_X_NEXT_CSID_PSP_USD:
-	case SRV6_ENDPOINT_BEHAVIOR_OPAQUE:
-	case SRV6_ENDPOINT_BEHAVIOR_RESERVED:
 	case SRV6_ENDPOINT_BEHAVIOR_END_B6_ENCAPS:
 	case SRV6_ENDPOINT_BEHAVIOR_END_B6_ENCAPS_RED:
 	case SRV6_ENDPOINT_BEHAVIOR_END_B6_ENCAPS_NEXT_CSID:
 	case SRV6_ENDPOINT_BEHAVIOR_END_B6_ENCAPS_RED_NEXT_CSID:
+	case SRV6_ENDPOINT_BEHAVIOR_OPAQUE:
+	case SRV6_ENDPOINT_BEHAVIOR_RESERVED:
 		zlog_warn("unsupported behavior: %u", sid->behavior);
 		break;
 	}
@@ -949,6 +1016,9 @@ void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
 
 	ctx.function_len = sid->addr.prefixlen - (ctx.block_len + ctx.node_len);
 
+	ctx.flv.lcblock_len = sid->locator->block_bits_length;
+	ctx.flv.lcnode_func_len = ctx.node_len + ctx.function_len;
+
 	zclient_send_localsid(static_zclient, ZEBRA_ROUTE_DELETE, &sid->addr.prefix,
 			      sid->addr.prefixlen, ifp->ifindex, action, &ctx);
 

From 2c5553dbe39f85b1557476caba6d52b304f042eb Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Fri, 27 Jun 2025 23:57:31 +0000
Subject: [PATCH 24/25] staticd: Uninstall SID from RIB when SID is released

When staticd receives a SID release notification from SID Manager, it
should uninstall the SID from the RIB, as the SID is no longer valid.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 staticd/static_zebra.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/staticd/static_zebra.c b/staticd/static_zebra.c
index 28c2a42008e8..47e0b9bd88a0 100644
--- a/staticd/static_zebra.c
+++ b/staticd/static_zebra.c
@@ -1495,6 +1495,11 @@ static int static_zebra_srv6_sid_notify(ZAPI_CALLBACK_ARGS)
 
 		UNSET_FLAG(sid->flags, STATIC_FLAG_SRV6_SID_VALID);
 
+		if (CHECK_FLAG(sid->flags, STATIC_FLAG_SRV6_SID_SENT_TO_ZEBRA)) {
+			static_zebra_srv6_sid_uninstall(sid);
+			UNSET_FLAG(sid->flags, STATIC_FLAG_SRV6_SID_SENT_TO_ZEBRA);
+		}
+
 		break;
 	case ZAPI_SRV6_SID_FAIL_ALLOC:
 		zlog_err("SRv6 SID %pI6 %s: Failed to allocate", &sid_addr,

From 21e21f81e007d17aa8fb54c4a07863752942b03f Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Sat, 10 May 2025 13:15:47 +0000
Subject: [PATCH 25/25] tests: Add topotest to verify SRv6 multiple locators

Add topotest to verify SRv6 static SIDs allocated from multiple locators

Add a topotest that attempts to allocate and install SIDs from multiple
locators and verify that SIDs are allocated/installed correctly.

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 .../__init__.py                               |    0
 .../expected_srv6_sids.json                   | 1196 +++++++++++++++++
 .../r1/frr.conf                               |   61 +
 .../r1/setup.sh                               |   19 +
 ...test_static_srv6_sids_multiple_locators.py |   82 ++
 5 files changed, 1358 insertions(+)
 create mode 100644 tests/topotests/static_srv6_sids_multiple_locators/__init__.py
 create mode 100644 tests/topotests/static_srv6_sids_multiple_locators/expected_srv6_sids.json
 create mode 100644 tests/topotests/static_srv6_sids_multiple_locators/r1/frr.conf
 create mode 100644 tests/topotests/static_srv6_sids_multiple_locators/r1/setup.sh
 create mode 100755 tests/topotests/static_srv6_sids_multiple_locators/test_static_srv6_sids_multiple_locators.py

diff --git a/tests/topotests/static_srv6_sids_multiple_locators/__init__.py b/tests/topotests/static_srv6_sids_multiple_locators/__init__.py
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/tests/topotests/static_srv6_sids_multiple_locators/expected_srv6_sids.json b/tests/topotests/static_srv6_sids_multiple_locators/expected_srv6_sids.json
new file mode 100644
index 000000000000..ddbfe0014c07
--- /dev/null
+++ b/tests/topotests/static_srv6_sids_multiple_locators/expected_srv6_sids.json
@@ -0,0 +1,1196 @@
+{
+	"fcbb:bb01:1::/48": [
+		{
+			"prefix": "fcbb:bb01:1::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uN",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 0,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:1:fe10::/64": [
+		{
+			"prefix": "fcbb:bb01:1:fe10::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf10",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT4",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 10
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:1:fe20::/64": [
+		{
+			"prefix": "fcbb:bb01:1:fe20::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf20",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT6",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 20
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:1:fe30::/64": [
+		{
+			"prefix": "fcbb:bb01:1:fe30::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf30",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 30
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:1:fe40::/64": [
+		{
+			"prefix": "fcbb:bb01:1:fe40::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uA"
+					},
+					"seg6localContext": {
+						"nh6": "2001::2"
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:2::/48": [
+		{
+			"prefix": "fcbb:bb01:2::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uN",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 0,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:2:fe10::/64": [
+		{
+			"prefix": "fcbb:bb01:2:fe10::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf10",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT4",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 10
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:2:fe20::/64": [
+		{
+			"prefix": "fcbb:bb01:2:fe20::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf20",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT6",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 20
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:2:fe30::/64": [
+		{
+			"prefix": "fcbb:bb01:2:fe30::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf30",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 30
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:2:fe40::/64": [
+		{
+			"prefix": "fcbb:bb01:2:fe40::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uA"
+					},
+					"seg6localContext": {
+						"nh6": "2001::2"
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:fe10::/48": [
+		{
+			"prefix": "fcbb:bb01:fe10::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf10",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT4",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 0,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 10
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:fe20::/48": [
+		{
+			"prefix": "fcbb:bb01:fe20::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf20",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT6",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 0,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 20
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:fe30::/48": [
+		{
+			"prefix": "fcbb:bb01:fe30::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf30",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 0,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 30
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:fe40::/48": [
+		{
+			"prefix": "fcbb:bb01:fe40::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uA"
+					},
+					"seg6localContext": {
+						"nh6": "2001::2"
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:1::/48": [
+		{
+			"prefix": "fcbb:bb02:1::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uN",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 0,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:1:fe10::/64": [
+		{
+			"prefix": "fcbb:bb02:1:fe10::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf10",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT4",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 10
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:1:fe20::/64": [
+		{
+			"prefix": "fcbb:bb02:1:fe20::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf30",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT6",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 30
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:1:fe30::/64": [
+		{
+			"prefix": "fcbb:bb02:1:fe30::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf20",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 20
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:1:fe40::/64": [
+		{
+			"prefix": "fcbb:bb02:1:fe40::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uA"
+					},
+					"seg6localContext": {
+						"nh6": "2001::2"
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:2::/48": [
+		{
+			"prefix": "fcbb:bb02:2::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uN",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 0,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:2:fe10::/64": [
+		{
+			"prefix": "fcbb:bb02:2:fe10::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf10",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT4",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 10
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:2:fe20::/64": [
+		{
+			"prefix": "fcbb:bb02:2:fe20::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf30",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT6",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 30
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:2:fe30::/64": [
+		{
+			"prefix": "fcbb:bb02:2:fe30::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf20",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 20
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:2:fe40::/64": [
+		{
+			"prefix": "fcbb:bb02:2:fe40::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uA"
+					},
+					"seg6localContext": {
+						"nh6": "2001::2"
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:fe10::/48": [
+		{
+			"prefix": "fcbb:bb02:fe10::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf10",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT4",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 0,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 10
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:fe20::/48": [
+		{
+			"prefix": "fcbb:bb02:fe20::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf30",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT6",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 0,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 30
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:fe30::/48": [
+		{
+			"prefix": "fcbb:bb02:fe30::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf20",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 0,
+							"funcLen": 16,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 20
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb02:fe40::/48": [
+		{
+			"prefix": "fcbb:bb02:fe40::/48",
+			"prefixLen": 48,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "sr0",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uA"
+					},
+					"seg6localContext": {
+						"nh6": "2001::2"
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:fff7:fe50::/64": [
+		{
+			"prefix": "fcbb:bb01:fff7:fe50::/64",
+			"prefixLen": 64,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf50",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 0,
+							"funcLen": 32,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 50
+					}
+				}
+			]
+		}
+	],
+	"fcbb:bb01:1:fff7:fe50::/80": [
+		{
+			"prefix": "fcbb:bb01:1:fff7:fe50::/80",
+			"prefixLen": 80,
+			"protocol": "static",
+			"vrfId": 0,
+			"vrfName": "default",
+			"selected": true,
+			"destSelected": true,
+			"distance": 1,
+			"metric": 0,
+			"installed": true,
+			"table": 254,
+			"internalStatus": 16,
+			"internalFlags": 9,
+			"internalNextHopNum": 1,
+			"internalNextHopActiveNum": 1,
+			"nexthops": [
+				{
+					"flags": 3,
+					"fib": true,
+					"directlyConnected": true,
+					"interfaceName": "Vrf50",
+					"active": true,
+					"weight": 1,
+					"seg6local": {
+						"action": "uDT46",
+						"sidStructure": {
+							"blockLen": 32,
+							"nodeLen": 16,
+							"funcLen": 32,
+							"argLen": 0
+						}
+					},
+					"seg6localContext": {
+						"table": 50
+					}
+				}
+			]
+		}
+	]
+}
\ No newline at end of file
diff --git a/tests/topotests/static_srv6_sids_multiple_locators/r1/frr.conf b/tests/topotests/static_srv6_sids_multiple_locators/r1/frr.conf
new file mode 100644
index 000000000000..7f52dea0b41e
--- /dev/null
+++ b/tests/topotests/static_srv6_sids_multiple_locators/r1/frr.conf
@@ -0,0 +1,61 @@
+hostname r1
+!
+segment-routing
+ srv6
+  locators
+   locator LOC1
+    prefix fcbb:bb01:1::/48
+    format usid-f3216
+   !
+   locator LOC2
+    prefix fcbb:bb01:2::/48
+    format usid-f3216
+   !
+   locator LOC3
+    prefix fcbb:bb02:1::/48
+    format usid-f3216
+   !
+   locator LOC4
+    prefix fcbb:bb02:2::/48
+    format usid-f3216
+   !
+  !
+  static-sids
+   sid fcbb:bb01:1::/48 locator LOC1 behavior uN
+   sid fcbb:bb01:1:fe10::/64 locator LOC1 behavior uDT4 vrf Vrf10
+   sid fcbb:bb01:1:fe20::/64 locator LOC1 behavior uDT6 vrf Vrf20
+   sid fcbb:bb01:1:fe30::/64 locator LOC1 behavior uDT46 vrf Vrf30
+   sid fcbb:bb01:1:fe40::/64 locator LOC1 behavior uA interface sr0 nexthop 2001::2
+   !
+   sid fcbb:bb01:2::/48 locator LOC2 behavior uN
+   sid fcbb:bb01:2:fe10::/64 locator LOC2 behavior uDT4 vrf Vrf10
+   sid fcbb:bb01:2:fe20::/64 locator LOC2 behavior uDT6 vrf Vrf20
+   sid fcbb:bb01:2:fe30::/64 locator LOC2 behavior uDT46 vrf Vrf30
+   sid fcbb:bb01:2:fe40::/64 locator LOC2 behavior uA interface sr0 nexthop 2001::2
+   !
+   sid fcbb:bb01:fe10::/48 locator LOC1 behavior uDT4 vrf Vrf10
+   sid fcbb:bb01:fe20::/48 locator LOC1 behavior uDT6 vrf Vrf20
+   sid fcbb:bb01:fe30::/48 locator LOC1 behavior uDT46 vrf Vrf30
+   sid fcbb:bb01:fe40::/48 locator LOC1 behavior uA interface sr0 nexthop 2001::2
+   !
+   sid fcbb:bb02:1::/48 locator LOC3 behavior uN
+   sid fcbb:bb02:1:fe10::/64 locator LOC3 behavior uDT4 vrf Vrf10
+   sid fcbb:bb02:1:fe20::/64 locator LOC3 behavior uDT6 vrf Vrf30
+   sid fcbb:bb02:1:fe30::/64 locator LOC3 behavior uDT46 vrf Vrf20
+   sid fcbb:bb02:1:fe40::/64 locator LOC3 behavior uA interface sr0 nexthop 2001::2
+   !
+   sid fcbb:bb02:2::/48 locator LOC4 behavior uN
+   sid fcbb:bb02:2:fe10::/64 locator LOC4 behavior uDT4 vrf Vrf10
+   sid fcbb:bb02:2:fe20::/64 locator LOC4 behavior uDT6 vrf Vrf30
+   sid fcbb:bb02:2:fe30::/64 locator LOC4 behavior uDT46 vrf Vrf20
+   sid fcbb:bb02:2:fe40::/64 locator LOC4 behavior uA interface sr0 nexthop 2001::2
+   !
+   sid fcbb:bb02:fe10::/48 locator LOC3 behavior uDT4 vrf Vrf10
+   sid fcbb:bb02:fe20::/48 locator LOC3 behavior uDT6 vrf Vrf30
+   sid fcbb:bb02:fe30::/48 locator LOC3 behavior uDT46 vrf Vrf20
+   sid fcbb:bb02:fe40::/48 locator LOC3 behavior uA interface sr0 nexthop 2001::2
+  !
+   sid fcbb:bb01:fff7:fe50::/64 locator LOC1 behavior uDT46 vrf Vrf50
+   sid fcbb:bb01:1:fff7:fe50::/80 locator LOC1 behavior uDT46 vrf Vrf50
+ !
+!
\ No newline at end of file
diff --git a/tests/topotests/static_srv6_sids_multiple_locators/r1/setup.sh b/tests/topotests/static_srv6_sids_multiple_locators/r1/setup.sh
new file mode 100644
index 000000000000..f419da0872de
--- /dev/null
+++ b/tests/topotests/static_srv6_sids_multiple_locators/r1/setup.sh
@@ -0,0 +1,19 @@
+ip link add sr0 type dummy
+ip link set sr0 up
+
+ip link add Vrf10 type vrf table 10
+ip link set Vrf10 up
+
+ip link add Vrf20 type vrf table 20
+ip link set Vrf20 up
+
+ip link add Vrf30 type vrf table 30
+ip link set Vrf30 up
+
+ip link add Vrf40 type vrf table 40
+ip link set Vrf40 up
+
+ip link add Vrf50 type vrf table 50
+ip link set Vrf50 up
+
+sysctl -w net.vrf.strict_mode=1
diff --git a/tests/topotests/static_srv6_sids_multiple_locators/test_static_srv6_sids_multiple_locators.py b/tests/topotests/static_srv6_sids_multiple_locators/test_static_srv6_sids_multiple_locators.py
new file mode 100755
index 000000000000..9e450281bb75
--- /dev/null
+++ b/tests/topotests/static_srv6_sids_multiple_locators/test_static_srv6_sids_multiple_locators.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python
+# SPDX-License-Identifier: ISC
+
+#
+# test_static_srv6_sids_multiple_locators.py
+#
+# Copyright (c) 2025 by
+# Carmine Scarpitta
+#
+
+"""
+test_static_srv6_sids_multiple_locators.py:
+Test for SRv6 static SIDs allocated from multiple locators
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+
+pytestmark = [pytest.mark.staticd]
+
+
+def open_json_file(filename):
+    try:
+        with open(filename, "r") as f:
+            return json.load(f)
+    except IOError:
+        assert False, "Could not read file {}".format(filename)
+
+
+def setup_module(mod):
+    tgen = Topogen({None: "r1"}, mod.__name__)
+    tgen.start_topology()
+    for rname, router in tgen.routers().items():
+        router.run("/bin/bash {}/{}/setup.sh".format(CWD, rname))
+        router.load_frr_config("frr.conf")
+    tgen.start_router()
+
+
+def teardown_module():
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_srv6_static_sids():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    def _check_srv6_static_sids(router, expected_route_file):
+        logger.info("checking zebra srv6 static sids")
+        output = json.loads(router.vtysh_cmd("show ipv6 route static json"))
+        expected = open_json_file("{}/{}".format(CWD, expected_route_file))
+        return topotest.json_cmp(output, expected)
+
+    def check_srv6_static_sids(router, expected_file):
+        func = functools.partial(_check_srv6_static_sids, router, expected_file)
+        _, result = topotest.run_and_expect(func, None, count=15, wait=1)
+        assert result is None, "Failed"
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Test for srv6 sids configuration")
+    check_srv6_static_sids(router, "expected_srv6_sids.json")
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.loc1(args))
